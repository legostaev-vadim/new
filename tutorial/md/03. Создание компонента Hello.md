<h3 id="create-component-hello">Создание компонента Hello</h3>

> Постарайтесь найти для своего редактора расширение, поддерживающие синтаксис **riot** в файлах **.tag**. Это сильно облегчит вам работу в дальнешей. Для редактора [Visual Studio Code](https://code.visualstudio.com/), такое [дополнение](https://github.com/crisward/riot-tag) имеется.

В папке **views** создайте файл **Hello.tag**. В данном файле будет распологаться наш компонент, который мы назовем **r-hello**.

> Все компоненты мы будем хранить в этой папке, поскольку они являются **представлениями**, что исходит из самого её названия.

> Префикс **r-** не является обязательным в названии тега компонента. Этим действием, мы лишь показываем его принадлежность к пользовательским тегам **Riot** и, одновременно, избегаем пересечения в пространстве имён со стандартными **html-элементами**, наподобие **header**. Например, если бы нам потребовался компонент **header**, то мы назвали бы его **r-header**.

В файле **Hello.tag** введите:

```html
<r-hello>
  <h1>Hello Riot!</h1>
</r-hello>
```

Затем, откройте файл **App.js**, закомментируйте или удалите приветствие, и подключите наш тег к приложению:

```js
// подключаем тег в приложение
import './views/Hello.tag'
```

> Точка в начале названия пути **'./views/Hello.tag'**, указывает на его относительную принадлежность.

Нам **не требуется** импортировать наш тег в переменную, вида:

 ```js
import Hello from './views/Hello.tag'
```
поскольку файлы компонентов **не содержат** ни какого экспорта. Мы импортируем тег прямо в файл.

Если мы сейчас попытаемся запустить **Webpack** командой:

```
npm run dev
```

то неизбежно получим сообщение об ошибке синтаксического разбора:

```
ERROR in ./src/views/Hello.tag 1:0
Module parse failed: Unexpected token (1:0)
You may need an appropriate loader to handle this file type.
> <r-hello>
|   <h1>Hello Riot!</h1>
| </r-hello>
 @ ./src/App.js 2:0-26
 @ multi (webpack)-dev-server/client?http://localhost:8080 ./src/App.js
```

Из которого можно сделать вывод, что нам потребуется установить соответствующий **загрузчик Webpack**.

> Несмотря на ошибку, **Webpack** не завершает своё выполнение в терминале. Остановить его работу можно командой **Ctrl+C**

Мы будем использовать загрузчик [riot-tag-new-loader](https://www.npmjs.com/package/riot-tag-new-loader).

Откройте терминал из папки **app** или переведите терминал в неё другим способом, и введите команду:

```
npm i -D riot-tag-new-loader
```

> Флаг **-D** указывает на зависимость **devDependencies**, которая используется для процесса разработки, а флаг **-S** на **dependencies**, в которой указываются пакеты, используемые для работы самого приложения.

Наш файл **package.json** теперь выглядит так:

```js
{
  "name": "app",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "dev": "webpack-dev-server -d --open",
    "build": "webpack -p"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "riot-tag-new-loader": "^1.0.14",
    "webpack": "^4.29.6",
    "webpack-cli": "^3.3.0",
    "webpack-dev-server": "^3.2.1"
  },
  "dependencies": {
    "riot": "^3.13.2",
    "riot-route": "^3.1.4"
  }
}
```

> Простая установка загрузчика, не избавит нас о вышеуказанной проблемы. Нам нужно будет добавить соответствующие **правила** в файле **webpack.config.js**.

Откроем файл **webpack.config.js** и добавим новое правило в свойство **rules**:

```js
const path = require('path')

module.exports = {
  entry: './src/App.js',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'build.js'
  },
  // добавляем новое правило для файлов тегов (.tag)
  module: {
    rules: [
      {
        test: /\.tag$/,
        exclude: /(node_modules|bower_components)/,
        use: 'riot-tag-new-loader'
      }
    ]
  }
}
```

Если мы сейчас снова попытаемся запустить **Webpack**:

```
npm run dev
```

то ошибка исчезнет, но ничего интересного, кроме пустой страницы в браузере, мы не увидим.

> Загрузчик лишь компилирует содержимое файлов тегов в обычный **JavaScript**, который **Webpack** подключает к нашему приложению.

Нам потребуется выполнить три завершающих действия:

+ подключить **riot.js** к нашему приложению
+ передать **riot.js** тег **Hello** для монтирования
+ подключить тег к странице **index.html**

Откроем файл **App.js** и в самом верху, **перед** подключением тега, добавим команду импорта:

```js
import riot from 'riot'
```

а в его конце, **после** команды подключения тега, добавим команду монтирования:

```js
riot.mount('r-hello')
```

Теперь наш файл **App.js** должен выглядеть вот так:

```js
// подключаем riot.js в приложение
import riot from 'riot'
// подключаем тег в приложение
import './views/Hello.tag'

// передаём тег для монтирования в riot.js
riot.mount('r-hello')
```

> Мы передаём **riot.js** название тега так, как мы указали его в файле **Hello.tag**, т.е. **r-hello**. Это же название мы будем использовать и при подключении тега на странице, а **Hello.tag** - это просто название файла, в котором хранится наш компонент.

Откроем файл **index.html** и подключим тег в **body**:

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Riot Application</title>
</head>
<body>

  <!-- подключаем тег -->
  <r-hello />
  
  <script src="build.js"></script>
</body>
</html>
```

И вот теперь, мы снова можем запустить **Webpack**:

```
npm run dev
```

после чего откроется страница в браузере с приветственным сообщением:

# Hello Riot!

Мы можем менять наше сообщение в компоненте **Hello**, и браузер автоматически будет обновлять страницу.

Это достигается благодаря тому, что мы в самом начале установили **webpack-dev-server**, а за само открытие страницы в браузере, отвечает его флаг **--open** команды **dev** в секции **scripts** файла **package.json**

```js
"scripts": {
  "dev": "webpack-dev-server -d --open",
  "build": "webpack -p"
}
```

На этом, мы заканчиваем с ознакомительной частью данного руководства и, уже в следующей части, перейдём непосредственно к написанию нашего приложения. И начнем мы с создания модуля для хранения нашего состояния.