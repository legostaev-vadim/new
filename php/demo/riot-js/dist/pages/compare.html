<h1 id="riot-vs-react--polymer"><strong>Riot</strong> vs <strong>React</strong> &amp; <strong>Polymer</strong></h1>

<p>Как Riot отличается от похожих проектов.</p>

<h2 id="react">React</h2>

<p>React и идея “связанности” послужили фундаментом для Riot. Согласно разработчикам Facebook:</p>

<blockquote>
  <p>“Templates separate technologies, not concerns.”</p>
</blockquote>

<p>Шаблоны разделяют технологии, не ответственность.
Мы придерживаемся этого принципа. Мы стремимся прийти к созданию повторно используемых компонентов, а не шаблонов. Разделяя логику наших интерфейсов и их шаблоны, мы, на самом деле, лишь усложняем себе жизнь.</p>

<p>Объединяя шаблон с его логикой в одном компоненте, мы делаем всю систему чище. Спасибо React за эту идею!</p>

<p>React отлично работает, и мы по-прежнему используем его в некоторых наших проектах. Но мы были обеспокоены размером React и его синтаксисом (<em>особенно</em> синтаксисом). Мы стали задумываться о том, что он может быть прощё не только внутренне, но и для конечного пользователя.</p>

<h3 id="react-syntax">Синтаксис React</h3>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">React</span> <span class="k">from</span> <span class="s1">'react'</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">render</span> <span class="p">}</span> <span class="k">from</span> <span class="s1">'react-dom'</span>

<span class="kd">class</span> <span class="nx">Todo</span> <span class="kd">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
  <span class="nx">state</span> <span class="o">=</span> <span class="p">{</span> <span class="na">items</span><span class="p">:</span> <span class="p">[],</span> <span class="na">value</span><span class="p">:</span> <span class="s1">''</span> <span class="p">}</span>
  <span class="nx">handleSubmit</span> <span class="o">=</span> <span class="nx">e</span> <span class="o">=&gt;</span>
    <span class="nx">e</span><span class="p">.</span><span class="nx">preventDefault</span><span class="p">()</span> <span class="o">||</span> <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span> <span class="na">items</span><span class="p">:</span> <span class="p">[...</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">items</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">value</span><span class="p">],</span> <span class="na">value</span><span class="p">:</span> <span class="s1">''</span> <span class="p">})</span>
  <span class="nx">handleChange</span> <span class="o">=</span> <span class="nx">e</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span> <span class="na">value</span><span class="p">:</span> <span class="nx">e</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">value</span> <span class="p">})</span>
  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span>
      <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="nx">h3</span><span class="o">&gt;</span><span class="nx">TODO</span><span class="o">&lt;</span><span class="sr">/h3</span><span class="err">&gt;
</span>        <span class="o">&lt;</span><span class="nx">ul</span><span class="o">&gt;</span>
          <span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">item</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="o">&lt;</span><span class="nx">li</span> <span class="nx">key</span><span class="o">=</span><span class="p">{</span><span class="nx">i</span><span class="p">}</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">item</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/li&gt;</span><span class="se">)</span><span class="err">}
</span>        <span class="o">&lt;</span><span class="sr">/ul</span><span class="err">&gt;
</span>        <span class="o">&lt;</span><span class="nx">form</span> <span class="nx">onSubmit</span><span class="o">=</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">handleSubmit</span><span class="p">}</span><span class="o">&gt;</span>
          <span class="o">&lt;</span><span class="nx">input</span> <span class="nx">value</span><span class="o">=</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">value</span><span class="p">}</span> <span class="nx">onChange</span><span class="o">=</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">handleChange</span><span class="p">}</span> <span class="sr">/</span><span class="err">&gt;
</span>          <span class="o">&lt;</span><span class="nx">button</span><span class="o">&gt;</span><span class="nx">Add</span> <span class="err">#</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nx">length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span>        <span class="o">&lt;</span><span class="sr">/form</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>    <span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">render</span><span class="p">(</span><span class="o">&lt;</span><span class="nx">Todo</span> <span class="o">/&gt;</span><span class="p">,</span> <span class="nx">mountNode</span><span class="p">)</span>
</code></pre></div></div>

<p>JSX смешивает HTML и JavaScript. Вы можете использовать HTML где угодно внутри компонента, внутри методов и при определении свойств.</p>

<h3 id="riot-syntax">Синтаксис Riot</h3>

<p>Теперь тоже самое с Riot:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;todo&gt;</span>
  <span class="nt">&lt;h3&gt;</span>TODO<span class="nt">&lt;/h3&gt;</span>

  <span class="nt">&lt;ul&gt;</span>
    <span class="nt">&lt;li</span> <span class="na">each=</span><span class="s">{</span> <span class="na">item</span><span class="err">,</span> <span class="na">i</span> <span class="na">in</span> <span class="na">items</span> <span class="err">}</span><span class="nt">&gt;</span>{ item }<span class="nt">&lt;/li&gt;</span>
  <span class="nt">&lt;/ul&gt;</span>

  <span class="nt">&lt;form</span> <span class="na">onsubmit=</span><span class="s">{</span> <span class="na">handleSubmit</span> <span class="err">}</span><span class="nt">&gt;</span>
    <span class="nt">&lt;input</span> <span class="na">ref=</span><span class="s">"input"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;button&gt;</span>Add #{ items.length + 1 }<span class="nt">&lt;/button&gt;</span>
  <span class="nt">&lt;/form&gt;</span>

  this.items = []

  handleSubmit(e) {
    e.preventDefault()
    var input = this.refs.input
    this.items.push(input.value)
    input.value = ''
  }
<span class="nt">&lt;/todo&gt;</span>
</code></pre></div></div>

<p>Этот пользовательский тег монтируется в страницу следующим образом:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;todo&gt;&lt;/todo&gt;</span>

<span class="nt">&lt;script&gt;</span><span class="nx">riot</span><span class="p">.</span><span class="nx">mount</span><span class="p">(</span><span class="s1">'todo'</span><span class="p">)</span><span class="nt">&lt;/script&gt;</span>
</code></pre></div></div>

<h3 id="same-same--but-different">Похоже, но не одно и то же!</h3>

<p>В Riot HTML и JavaScript используются гораздо более привычным способом. Оба находятся в одном компоненте, но аккуратно отделены друг от друга. При этом, HTML можно смешивать с выражениями JavaScript.</p>

<p>Мы не используем собственный язык, за исключением выражений в фигурных скобках.</p>

<p>Вам приходится работать с меньшим объёмом кода. Меньше скобок, запятых, системных методов и свойств. Строки можно использовать как <code class="highlighter-rouge">"Hello {world}"</code> вместо <code class="highlighter-rouge">"Hello " + this.state.world</code>, и методы могут быть определены с помощью компактного ES6 синтаксиса. Меньше во всём.</p>

<p>Мы считаем, что синтаксис Riot - наиболее чистый способ отделения шаблона и его логики, который позволяет пользоваться всеми преимуществами изолированных, пригодных для повторного использования компонентов.</p>

<h3 id="virtual-dom-vs-expressions-binding">Виртуальный DOM vs привязка выражений</h3>

<p>Когда компонент инициализируется, React создает его Виртуальный DOM, а Riot, с другой стороны, только перебирает дерево DOM.</p>

<p>Riot берёт выражения из DOM и сохраняет их в массиве. Каждое выражение имеет указатель на элемент DOM. При каждом выполнении этого выражения, оно сравнивается со значением в DOM. Когда значение меняется, элемент DOM обновляется.</p>

<p>Так как выражение может быть закэшировано, цикл обновления очень быстрый. Проход 100 или 1000 выражений, обычно занимает 1мс и меньше.</p>

<p>Алгоритм React гораздо сложнее из-за того, что HTML может непредвиденно изменяться после каждого обновления. Получив эту проблему, разработчики Facebook проделали впечатляющую работу с ней.</p>

<p>Мы увидели, что сложность, связанную с определением различий, можно избежать.</p>

<p>В Riot, HTML структура фиксированная. Только циклы и условные выражения могут добавлять и удалять элементы. Но <code class="highlighter-rouge">div</code>, например, не может стать <code class="highlighter-rouge">label</code>. Riot только обновляет выражения, без сложных замен поддеревьев.</p>

<h3 id="flux-and-routing">Flux и маршрутизация</h3>

<p>React работает только с UI, и это хорошо. Все хорошие проекты имеют четкую направленность.</p>

<p>Facebook рекомендует использовать <a href="http://facebook.github.io/flux/docs/overview.html">Flux</a> для структурирования кода на стороне клиента. Это скорее паттерн проектирования, сочетающий хорошие идеи, чем фреймворк.</p>

<p>Riot предоставляется в комплекте с пользовательскими тегами, событийной системой (observable) и маршрутизатором. Мы считаем это минимальным набором для создания приложений на клиенте. События привносят модульность, маршрутизатор заботится о URL и кнопке “назад”, а пользовательские теги берут на себя UI.</p>

<p>Так же, как и Flux, Riot является очень гибким и оставляет основные архитектурные решения за разработчиком. Это просто библиотека, которая помогает вам достичь цели.</p>

<p>Вы можете создать Flux-подобную систему, используя observable и router, встроенные в Riot. Вообще-то, такие инструменты <a href="https://github.com/jimsparkman/RiotControl">уже есть</a>.</p>

<h3 id="3x-bigger">В 3 раза больше</h3>

<p>React (v16.4.0) в 3 раза больше, чем Riot.</p>

<p><small><em>react.min.js</em> – 33.27KB (gzip)</small>
<span class="bar red"></span></p>

<p><small><em>riot.min.js</em> – <span class="riot-size">10.85KB (gzip)</span></small>
<span class="bar blue" style="width: 32.61196272918545%"></span></p>

<p><br></p>

<p>Маршрутизатор рекомендуемый React (v4.1.1) в 6 раз больше маршрутизатора Riot.</p>

<p><small><em>react-router.min.js</em> – 10.95KB (gzip)</small>
<span class="bar red"></span></p>

<p><small><em>react-mini-router.min.js</em> – 4.52KB (gzip)</small>
<span class="bar red" style="width: 41.278538812785385%"></span></p>

<p><small><em>riot.route.min.js</em> – 1.77KB (gzip)</small>
<span class="bar blue" style="width:16.164383561643834%"></span></p>

<p>Правда, это сравнение немного несправедливо, ведь у <a href="https://github.com/rackt/react-router">react-router</a> гораздо больше возможностей. Но представленные выше графики, прекрасно иллюстрируют главную цель Riot - предоставить наиболее минималистичный API для работы.</p>

<p>Экосистема React более “фреймворковая” и это провоцирует громоздкие API. Компактная альтернатива <a href="https://github.com/larrymyers/react-mini-router">react-mini-router</a> не пользуется популярностью в сообществе React.</p>

<h2 id="polymer">Polymer</h2>

<p>Polymer взял стандартные веб-компоненты и сделал их доступными для современных браузеров. Это позволяет вам создавать пользовательские теги в стандартной манере.</p>

<p>В принципе, Riot делает тоже самое, но иначе.</p>

<ol>
  <li>
    <p>Riot обновляет только те элементы, у которых есть изменения, чтобы сократить манипуляции с DOM.</p>
  </li>
  <li>
    <p>Синтаксис Polymer более сложный и требует изучения многих книг.</p>
  </li>
  <li>
    <p>Отдельные компоненты импортируются через HTML <code class="highlighter-rouge">link rel="import"</code>. Приходится прибегать к последовательным XHR-запросам, что делает Polymer крайне медленным, если не использовать <a href="https://github.com/polymer/vulcanize">vulcanize</a>. Пользовательские теги в Riot импортируются через <code class="highlighter-rouge">script src</code> и множество тегов могут быть объединены тем же способом, что и обычные js-файлы.</p>
  </li>
  <li>
    <p>Нет возможности рендеринга на стороне сервера.</p>
  </li>
</ol>

<h3 id="6x-bigger">В 6 раз больше</h3>

<p>Polymer(v1.8.0) + WebComponents(v0.7.24) в 6 раз больше, чем Riot</p>

<p><small><em>polymer.min.js</em> – 49.38KB (gzip)</small>
<span class="bar red"></span></p>

<p><small><em>riot.min.js</em> – <span class="riot-size">10.85KB (gzip)</span></small>
<span class="bar blue" style="width: 21.972458485216688%"></span></p>

<p>Веб-компоненты считаются <a href="http://developer.telerik.com/featured/web-components-arent-ready-production-yet/">основой всех проблем polyfilling</a>. Это главная причина, по которой Polymer нуждается в таком количестве кода.</p>

<h2 id="web-components">Веб-компоненты</h2>

<p>Веб-компоненты — <a href="https://ru.wikipedia.org/wiki/%D0%92%D0%B5%D0%B1-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D1%8B">технология</a>, которая позволяет создавать многократно используемые компоненты в веб-документах и веб-приложениях. Веб-компоненты поддерживаются веб-браузерами напрямую и не требуют дополнительных библиотек для работы.</p>

<p>Модель веб-компонентов подразумевает инкапсуляцию и совместимость отдельных HTML-элементов.</p>

<p>На данный момент, частичная поддержка существует в браузерах Chrome, Firefox, Opera и Safari. Для браузеров не поддерживающих веб-компоненты реализованы полифилы.</p>