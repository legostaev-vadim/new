<div id="tabs">
  <a href="/v2/ru/api/" class="current">Теги</a>
  <a href="/v2/ru/api/compiler/">Компилятор</a>
  <a href="/v2/ru/api/observable/">Наблюдатель</a>
  <a href="/v2/ru/api/route/">Маршрутизатор</a>
  <a href="/v2/ru/api/misc/">Разное</a>
</div>

<h1>API · Пользовательские теги</h1>

<div id="toc"><p><a href="#монтирование">Монтирование</a></p><p><a href="#рендеринг">Рендеринг</a></p><p><a href="#-экземпляр-пользовательского-тега">Экземпляр пользовательского тега</a></p><p><a href="#отмонтирование">Отмонтирование</a></p><p><a href="#вложенные-теги">Вложенные теги</a></p><p><a href="#-встраивание-html-в-содержимое-тега-yield">Встраивание HTML в содержимое тега (yield)</a></p><p><a href="#события">События</a></p><p><a href="#зарезервированные-слова">Зарезервированные слова</a></p><p><a href="#создание-тега-вручную">Создание тега вручную</a></p></div>

<h2 id="монтирование">Монтирование</h2>

<h3 id="-riotmountcustomtagselector-opts"><a name="mount"></a> riot.mount(customTagSelector, [opts])</h3>

<p><code class="highlighter-rouge">customTagSelector</code> выбирает элементы со страницы и монтирует их как пользовательские теги. Имя выбранного элемента должно совпадать с именем пользовательского тега.</p>

<p><code class="highlighter-rouge">opts</code> - необязательный объект параметров, который передаётся в теги. Это может быть что угодно, начиная от простого объекта до большого API приложения. Или это может быть Flux-хранилище. Это зависит от того, как вы структурируете ваше приложение. Вы можете узнать больше о модульности <a href="/ru/guide/application-design/#modularity">здесь</a>. <em>Обратите внимание,</em> что атрибуты монтируемого тега имеют более высокий приоритет над одноименными опциями из <code class="highlighter-rouge">opts</code>.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// выбрать и смонтировать все &lt;pricing&gt; теги на странице</span>
<span class="kd">var</span> <span class="nx">tags</span> <span class="o">=</span> <span class="nx">riot</span><span class="p">.</span><span class="nx">mount</span><span class="p">(</span><span class="s1">'pricing'</span><span class="p">)</span>

<span class="c1">// смонтировать все пользовательские теги с классом .customer</span>
<span class="kd">var</span> <span class="nx">tags</span> <span class="o">=</span> <span class="nx">riot</span><span class="p">.</span><span class="nx">mount</span><span class="p">(</span><span class="s1">'.customer'</span><span class="p">)</span>

<span class="c1">// смонтировать тег &lt;account&gt; и передать ему объект api</span>
<span class="kd">var</span> <span class="nx">tags</span> <span class="o">=</span> <span class="nx">riot</span><span class="p">.</span><span class="nx">mount</span><span class="p">(</span><span class="s1">'account'</span><span class="p">,</span> <span class="nx">api</span><span class="p">)</span>
</code></pre></div></div>

<p>@returns: массив смонтированных <a href="#tag-instance">тегов</a></p>

<h3 id="-riotmount-opts"><a name="mount-star"></a> riot.mount(‘*’, [opts])</h3>

<p>Специальный селектор “*” используется для монтирования всех пользовательских тегов на странице:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">riot</span><span class="p">.</span><span class="nx">mount</span><span class="p">(</span><span class="s1">'*'</span><span class="p">)</span>
</code></pre></div></div>

<p>@returns: массив смонтированных <a href="#tag-instance">тегов</a></p>

<h3 id="-riotmountselector-tagname-opts"><a name="mount-tag"></a> riot.mount(selector, tagName, [opts])</h3>

<p>Здесь</p>
<ul>
  <li><code class="highlighter-rouge">selector</code> выбирает любой элемент DOM, к которому будет примонтирован тег</li>
  <li><code class="highlighter-rouge">tagName</code> определяет, какой тег будет использоваться</li>
  <li><code class="highlighter-rouge">opts</code> необязательный объект, содержащий параметры</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// монтирует тег "my-tag" в div#main и передаёт в него параметры из объекта api</span>
<span class="kd">var</span> <span class="nx">tags</span> <span class="o">=</span> <span class="nx">riot</span><span class="p">.</span><span class="nx">mount</span><span class="p">(</span><span class="s1">'div#main'</span><span class="p">,</span> <span class="s1">'my-tag'</span><span class="p">,</span> <span class="nx">api</span><span class="p">)</span>
</code></pre></div></div>

<p>@returns: массив смонтированных <a href="#tag-instance">тегов</a></p>

<h3 id="-riotmountdomnode-tagname-opts"><a name="mount-dom"></a> riot.mount(domNode, tagName, [opts])</h3>

<p>Монтирует пользовательский тег tagName в конкретный элемент DOM domNode. Например:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// монтируем "users" в определённый DOM элемент и отправляем в него объект api.
riot.mount(document.getElementById('slide'), 'users', api)
</code></pre></div></div>

<p>@returns: массив смонтированных <a href="#tag-instance">тегов</a></p>

<h2 id="рендеринг">Рендеринг</h2>

<h3 id="-riotrendertagname-opts"><a name="render"></a> riot.render(tagName, [opts])</h3>

<p>Рендерит пользовательский тег как html. Этот метод доступен только <em>на серверной стороне</em> (Node/io.js). Например:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// рендерим "my-tag" в html
var mytag = require('my-tag')
riot.render(mytag, { foo: 'bar' })
</code></pre></div></div>

<p>@returns: строка html</p>

<h2 id="-экземпляр-пользовательского-тега"><a name="tag-instance"></a> Экземпляр пользовательского тега</h2>

<p>Это свойства есть у каждого сущности тега;</p>

<ul>
  <li><code class="highlighter-rouge">opts</code> - объект, который передаётся в тег в качестве параметров</li>
  <li><code class="highlighter-rouge">parent</code> - родительский тег</li>
  <li><code class="highlighter-rouge">root</code> - DOM элемент, к которому примонтирован тег</li>
  <li><code class="highlighter-rouge">tags</code> - внутренние пользовательские теги</li>
</ul>

<p>Вы можете использовать эти свойства как в HTML, так и в JavaScript. Например:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;my-tag&gt;</span>
  <span class="nt">&lt;h3&gt;</span>{ opts.title }<span class="nt">&lt;/h3&gt;</span>

  var title = opts.title
<span class="nt">&lt;/my-tag&gt;</span>
</code></pre></div></div>

<p>Вы можете свободно задавать значения этих свойств и читать их HTML из выражений. Например:</p>

<p>``2` html</p>
<my-tag>
  <h3>{ title }</h3>

  this.title = opts.title
</my-tag>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>

## Обновление

### &lt;a name="tag-update"&gt;&lt;/a&gt; this.update()

Обновление всех выражений в экземпляре тега, а также во всех всех вложенных тегах. Этот метод вызывается автоматически каждый раз, когда пользователь взаимодействует с приложением.

Riot не обновляет пользовательский интерфейс автоматически, поэтому вы должны вызвать этот метод вручную. Это обычно происходит после каких-либо событий, на связанный с UI: после `setTimeout`, AJAX вызова или из-за какого-либо события на сервере. Например:

``` html
&lt;my-tag&gt;

  &lt;input name="username" onblur={ validate }&gt;
  &lt;span class="tooltip" show={ error }&gt;{ error }&lt;/span&gt;

  var self = this

  validate() {
    $.get('/validate/username/' + this.username.value)
      .fail(function(error_message) {
        self.error = error_message
        self.update()
      })
  }
&lt;/my-tag&gt;
</code></pre></div></div>
<p>На примере выше сообщение об ошибке отображается в UI после того, как вызывается метод <code class="highlighter-rouge">update()</code>. Мы передали в <code class="highlighter-rouge">self</code> значение из <code class="highlighter-rouge">this</code> так как внутри AJAX обратного вызова <code class="highlighter-rouge">this</code> имеет другой контекст.</p>

<h3 id="-thisupdatedata"><a name="tag-update-data"></a> this.update(data)</h3>

<p>Устанавливает значения свойств текущего элемента и обновляет выражения. Например, вместо этого:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">self</span><span class="p">.</span><span class="nx">error</span> <span class="o">=</span> <span class="nx">error_message</span>
<span class="nb">self</span><span class="p">.</span><span class="nx">update</span><span class="p">()</span>
</code></pre></div></div>

<p>Вы можете делать так:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">self</span><span class="p">.</span><span class="nx">update</span><span class="p">({</span> <span class="na">error</span><span class="p">:</span> <span class="nx">error_message</span> <span class="p">})</span>
</code></pre></div></div>

<p>Что выглядит короче и чище.</p>

<h3 id="-riotupdate"><a name="update"></a> riot.update()</h3>

<p>Обновляет все примонтированные пользовательские теги.</p>

<p>@returns: массив <a href="#tag-instance">тегов</a> которые примонтированы на странице.</p>

<h2 id="отмонтирование">Отмонтирование</h2>

<h3 id="-thisunmountkeeptheparent"><a name="tag-unmount"></a> this.unmount(keepTheParent)</h3>

<p>Открепляет тег и его дочерние элементы и вызывает событие тега “unmount”.
Если вы хотите открепить тег, но оставить его тег-контейнер, вызывайте метод “unmount” с параметром <code class="highlighter-rouge">true</code>.</p>

<p>Удаление тега из DOM:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">mytag</span><span class="p">.</span><span class="nx">unmount</span><span class="p">()</span>
</code></pre></div></div>

<p>Удаление пользовательского тега, за исключением тега, в который он был смонтирован:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">mytag</span><span class="p">.</span><span class="nx">unmount</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="вложенные-теги">Вложенные теги</h2>

<p>У вас есть доступ к вложенным тегам благодаря атрибуту <code class="highlighter-rouge">tags</code>:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;my-tag&gt;</span>
  <span class="nt">&lt;child&gt;&lt;/child&gt;</span>
  var child = this.tags.child
<span class="nt">&lt;/my-tag&gt;</span>
</code></pre></div></div>
<p>Если вложенных тегов больше одного, они помещаются в массив <code class="highlighter-rouge">this.tags.child[n]</code></p>

<p>Вы можете давать тегам названия через атрибут <code class="highlighter-rouge">name</code>.</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;my-tag&gt;</span>

  <span class="nt">&lt;child</span> <span class="na">name=</span><span class="s">"my_nested_tag"</span><span class="nt">&gt;&lt;/child&gt;</span>

  // обращение к вложенному тегу
  var child = this.tags.my_nested_tag

<span class="nt">&lt;/my-tag&gt;</span>
</code></pre></div></div>

<p>Вложенные теги инициализируются сразу после того, как монтируется родительский тег, так что вложенные теги и все их методы доступны в событии “mount”.</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;my-tag&gt;</span>

  <span class="nt">&lt;child</span> <span class="na">name=</span><span class="s">"my_nested_tag"</span><span class="nt">&gt;&lt;/child&gt;</span>

  this.on('mount', function() {
    this.tags.my_nested_tag.someMethod()
  })

<span class="nt">&lt;/my-tag&gt;</span>
</code></pre></div></div>

<h2 id="-встраивание-html-в-содержимое-тега-yield"><a name="yield"></a> Встраивание HTML в содержимое тега (yield)</h2>

<p>Специальный тег <code class="highlighter-rouge">&lt;yield&gt;</code> позволяет расширять шаблон пользовательского тега уже после компиляции.</p>

<p>Например, у нас есть тег <code class="highlighter-rouge">my-post</code></p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;my-post&gt;</span>
  <span class="nt">&lt;h1&gt;</span>{ opts.title }<span class="nt">&lt;/h1&gt;</span>
  <span class="nt">&lt;yield/&gt;</span>
  this.id = 666
<span class="nt">&lt;/my-post&gt;</span>
</code></pre></div></div>

<p>в любой момент мы подключаем тег <code class="highlighter-rouge">&lt;my-post&gt;</code> в нашем приложении</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;my-post</span> <span class="na">title=</span><span class="s">"What a great title"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;p</span> <span class="na">id=</span><span class="s">"my-content-{ id }"</span><span class="nt">&gt;</span>My beautiful post is just awesome<span class="nt">&lt;/p&gt;</span>
<span class="nt">&lt;/my-post&gt;</span>
</code></pre></div></div>

<p>при монтировании <code class="highlighter-rouge">riot.mount('my-post')</code> тег будет выглядеть так:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;my-post&gt;</span>
  <span class="nt">&lt;h1&gt;</span>What a great title<span class="nt">&lt;/h1&gt;</span>
  <span class="nt">&lt;p</span> <span class="na">id=</span><span class="s">"my-content-666"</span><span class="nt">&gt;</span>My beautiful post is just awesome<span class="nt">&lt;/p&gt;</span>
<span class="nt">&lt;/my-post&gt;</span>
</code></pre></div></div>

<h4 id="yield-и-циклы">Yield и циклы</h4>

<p>Тег <code class="highlighter-rouge">&lt;yield&gt;</code> может быть использован в циклах или в дочерних тегах. Но вы должны быть внимательны, так как в этом случае <strong>всегда используются данные из дочерних тегов</strong>.</p>

<p>Имеем компонент <code class="highlighter-rouge">blog.tag</code></p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;blog&gt;</span>
  <span class="nt">&lt;h1&gt;</span>{ title }<span class="nt">&lt;/h1&gt;</span>
  <span class="nt">&lt;my-post</span> <span class="na">each=</span><span class="s">{</span> <span class="na">posts</span> <span class="err">}</span><span class="nt">&gt;</span>
    <span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">{</span> <span class="na">this</span><span class="err">.</span><span class="na">parent</span><span class="err">.</span><span class="na">backToHome</span> <span class="err">}</span><span class="nt">&gt;</span>Back to home<span class="nt">&lt;/a&gt;</span>
    <span class="nt">&lt;div</span> <span class="na">onclick=</span><span class="s">{</span> <span class="na">this</span><span class="err">.</span><span class="na">parent</span><span class="err">.</span><span class="na">deleteAllPosts</span> <span class="err">}</span><span class="nt">&gt;</span>Delete all the posts<span class="nt">&lt;/div&gt;</span>
  <span class="nt">&lt;/my-post&gt;</span>

  this.backToHome = '/homepage'
  this.title = 'my blog title'

  this.posts = [
    { title: "post 1", description: 'my post description' },
    { title: "post 2", description: 'my post description' }
  ]

  // bind нужен для сохранения контекста переменной this
  deleteAllPosts() {
    this.posts = []
    this.update()
  }.bind(this)

<span class="nt">&lt;/blog&gt;</span>

<span class="nt">&lt;my-post&gt;</span>
  <span class="nt">&lt;h2&gt;</span>{ title }<span class="nt">&lt;/h2&gt;</span>
  <span class="nt">&lt;p&gt;</span>{ description }<span class="nt">&lt;/p&gt;</span>
  <span class="nt">&lt;yield/&gt;</span>
<span class="nt">&lt;/my-post&gt;</span>

</code></pre></div></div>

<p>После компиляции будет выглядеть так:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;blog&gt;</span>
  <span class="nt">&lt;h1&gt;</span>my blog title<span class="nt">&lt;/h1&gt;</span>
  <span class="nt">&lt;my-post&gt;</span>
    <span class="nt">&lt;h2&gt;</span>post 1<span class="nt">&lt;/h2&gt;</span>
    <span class="nt">&lt;p&gt;</span>my post description<span class="nt">&lt;/p&gt;</span>
    <span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">"/homepage"</span><span class="nt">&gt;</span>Back to home<span class="nt">&lt;/a&gt;</span>
    <span class="nt">&lt;div&gt;</span>Delete all the posts<span class="nt">&lt;/div&gt;</span>
  <span class="nt">&lt;/my-post&gt;</span>
  <span class="nt">&lt;my-post&gt;</span>
    <span class="nt">&lt;h2&gt;</span>post 2<span class="nt">&lt;/h2&gt;</span>
    <span class="nt">&lt;p&gt;</span>my post description<span class="nt">&lt;/p&gt;</span>
    <span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">"/homepage"</span><span class="nt">&gt;</span>Back to home<span class="nt">&lt;/a&gt;</span>
    <span class="nt">&lt;div&gt;</span>Delete all the posts<span class="nt">&lt;/div&gt;</span>
  <span class="nt">&lt;/my-post&gt;</span>
<span class="nt">&lt;/blog&gt;</span>
</code></pre></div></div>

<h2 id="события">События</h2>

<p>Каждый экземпляр пользовательского тега - это <a href="/ru/api/observable/">наблюдатель</a> поэтому, вы можете использовать методы <code class="highlighter-rouge">on</code> и <code class="highlighter-rouge">one</code> для того, чтобы наблюдать за событиями тега. Вот список поддерживаемых в Riot событий:</p>

<ul>
  <li>“update” – вызывается непосредственно перед обновлением тега. Позволяет изменить данные тега перед тем, как выражения в шаблоне будут пересчитаны.</li>
  <li>“updated” – вызывается сразу после обновления тега. Позволяет манипулировать с обновлённым DOM-деревом</li>
  <li>“mount” – сразу после того, как тег примонтируется в приложении</li>
  <li>“unmount” – сразу после того, как приложение будет отмонтированно</li>
</ul>

<p>Пример:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// освобождаем ресурсы когда тег уже не является частью DOM</span>
<span class="k">this</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'unmount'</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">clearTimeout</span><span class="p">(</span><span class="nx">timer</span><span class="p">)</span>
<span class="p">})</span>
</code></pre></div></div>

<h2 id="зарезервированные-слова">Зарезервированные слова</h2>

<p>Вышеперечисленные имена методов и переменные - зарезервированные слова в Riot. Не используйте эти названия для атрибутов тегов или их методов: <code class="highlighter-rouge">opts</code>, <code class="highlighter-rouge">parent</code>, <code class="highlighter-rouge">root</code>, <code class="highlighter-rouge">update</code>, <code class="highlighter-rouge">unmount</code>, <code class="highlighter-rouge">on</code>, <code class="highlighter-rouge">off</code>, <code class="highlighter-rouge">one</code> and <code class="highlighter-rouge">trigger</code>. Переменные, начинающиеся с подчеркивания (например: <code class="highlighter-rouge">this._item</code>) тоже зарезервированы для внутреннего использования. Локальные переменные можно называть как угодно. Например:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">my</span><span class="o">-</span><span class="nx">tag</span><span class="o">&gt;</span>

  <span class="c1">// можно</span>
  <span class="kd">function</span> <span class="nx">update</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span><span class="err">&nbsp;</span>

  <span class="c1">// нельзя</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">update</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>

  <span class="c1">// нельзя</span>
  <span class="nx">update</span><span class="p">()</span> <span class="p">{</span>

  <span class="p">}</span>

<span class="o">&lt;</span><span class="sr">/my-tag</span><span class="err">&gt;
</span></code></pre></div></div>

<h2 id="создание-тега-вручную">Создание тега вручную</h2>

<h3 id="-riottagtagname-html-css-attrs-constructor"><a name="tag"></a> riot.tag(tagName, html, [css], [attrs], [constructor])</h3>

<p>Метод создаёт новую сущность тега “вручную”, без компилятора.</p>

<ul>
  <li><code class="highlighter-rouge">tagName</code> имя тега</li>
  <li><code class="highlighter-rouge">html</code> шаблон с <a href="/ru/guide/#expressions">выражениями</a></li>
  <li><code class="highlighter-rouge">css</code> стили (необязательно)</li>
  <li><code class="highlighter-rouge">attrs</code> атрибуты (необязательно)</li>
  <li><code class="highlighter-rouge">constructor</code> функция, которая будет вызвана перед вычислением выражений и перед тем, как тег будет смонтирован</li>
</ul>

<h4 id="пример">Пример</h4>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">riot</span><span class="p">.</span><span class="nx">tag</span><span class="p">(</span><span class="s1">'timer'</span><span class="p">,</span>
  <span class="s1">'&lt;p&gt;Времени прошло: { time }&lt;/p&gt;'</span><span class="p">,</span>
  <span class="s1">'timer { display: block; border: 2px }'</span><span class="p">,</span>
  <span class="s1">'class="tic-toc"'</span><span class="p">,</span>
  <span class="kd">function</span> <span class="p">(</span><span class="nx">opts</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nb">self</span> <span class="o">=</span> <span class="k">this</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">time</span> <span class="o">=</span> <span class="nx">opts</span><span class="p">.</span><span class="nx">start</span> <span class="o">||</span> <span class="mi">0</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">tick</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
      <span class="nb">self</span><span class="p">.</span><span class="nx">update</span><span class="p">({</span> <span class="na">time</span><span class="p">:</span> <span class="o">++</span><span class="nb">self</span><span class="p">.</span><span class="nx">time</span> <span class="p">})</span>
    <span class="p">}</span>

    <span class="kd">var</span> <span class="nx">timer</span> <span class="o">=</span> <span class="nx">setInterval</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">tick</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'unmount'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
      <span class="nx">clearInterval</span><span class="p">(</span><span class="nx">timer</span><span class="p">)</span>
    <span class="p">})</span>

  <span class="p">})</span>
</code></pre></div></div>

<p>Смотри документацию к <a href="http://jsfiddle.net/gnumanth/h9kuozp5/">timer demo</a> и <a href="#tag-instance">riot.tag</a> API для подробной информации.</p>

<p><span class="tag red">Внимание</span>, при использовании <code class="highlighter-rouge">riot.tag</code> вы не сможете насладиться преимуществами компилятора и список нижеперечисленных функций не поддерживается:</p>

<ol>
  <li>Самозакрывающиеся теги</li>
  <li>Незаковыченные выражения. Пишите <code class="highlighter-rouge">value="{ val }"</code> вместо <code class="highlighter-rouge">value={ val }</code></li>
  <li>Boolean attributes. Write <code class="highlighter-rouge">__checked="{ flag }"</code> instead of <code class="highlighter-rouge">checked={ flag }</code></li>
  <li>Короткий синтаксис из ES6</li>
  <li><code class="highlighter-rouge">&lt;img src={ src }&gt;</code> должно быть написано как <code class="highlighter-rouge">&lt;img riot-src={ src }&gt;</code> для избегания некорректных запросов к серверу</li>
  <li><code class="highlighter-rouge">style="color: { color }"</code> должно быть написано как <code class="highlighter-rouge">riot-style="color: { color }"</code> чтобы это работало в IE</li>
  <li>Локальные CSS стили</li>
</ol>

<p>Вы можете получить преимущества <code class="highlighter-rouge">&lt;template&gt;</code> или <code class="highlighter-rouge">&lt;script&gt;</code> следующим образом:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;script </span><span class="na">type=</span><span class="s">"tmpl"</span> <span class="na">id=</span><span class="s">"my_tmpl"</span><span class="nt">&gt;</span>
  <span class="o">&lt;</span><span class="nx">h3</span><span class="o">&gt;</span><span class="p">{</span> <span class="nx">opts</span><span class="p">.</span><span class="nx">hello</span> <span class="p">}</span><span class="o">&lt;</span><span class="sr">/h3</span><span class="err">&gt;
</span>  <span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="nx">And</span> <span class="nx">a</span> <span class="nx">paragraph</span><span class="o">&lt;</span><span class="sr">/p</span><span class="err">&gt;
</span><span class="nt">&lt;/script&gt;</span>

<span class="nt">&lt;script&gt;</span>
<span class="nx">riot</span><span class="p">.</span><span class="nx">tag</span><span class="p">(</span><span class="s1">'tag-name'</span><span class="p">,</span> <span class="nx">my_tmpl</span><span class="p">.</span><span class="nx">innerHTML</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">opts</span><span class="p">)</span> <span class="p">{</span>

<span class="p">})</span>
<span class="nt">&lt;/script&gt;</span>
</code></pre></div></div>

<h3 id="riottagimpl-conf-innerhtml">riot.Tag(impl, conf, innerHTML)</h3>

<p><span class="tag red">экспериментальный</span></p>

<p>В 2.3 мы предоставили доступ к методу Tag, ранее использовавшемуся лишь внутренне. Блягодаря этому, вы можете применять более гибкий подход к созданию тегов.</p>

<ul>
  <li><code class="highlighter-rouge">impl</code>
    <ul>
      <li><code class="highlighter-rouge">tmpl</code> шаблон тега</li>
      <li><code class="highlighter-rouge">fn(opts)</code> функция обратного вызова. Автоматически вызывается при монтировании</li>
      <li><code class="highlighter-rouge">attrs</code> аттрибуты тега</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">conf</code>
    <ul>
      <li><code class="highlighter-rouge">root</code> узел DOM, в который будет примонтирован тег</li>
      <li><code class="highlighter-rouge">opts</code> опции тега</li>
      <li><code class="highlighter-rouge">isLoop</code> флаг, указывающий на то, данный тег используется для цикла?</li>
      <li><code class="highlighter-rouge">hasImpl</code> был ли этот тег уже зарегистрирован через riot.tag?</li>
      <li><code class="highlighter-rouge">item</code> элемент цикла (если используется для цикла)</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">innerHTML</code> html который будет использоваться для <code class="highlighter-rouge">yield</code> в шаблоне.</li>
</ul>

<p>Пример с ES2015:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">class</span> <span class="nx">MyTag</span> <span class="kd">extends</span> <span class="nx">riot</span><span class="p">.</span><span class="nx">Tag</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">el</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">super</span><span class="p">({</span> <span class="na">tmpl</span><span class="p">:</span> <span class="nx">MyTag</span><span class="p">.</span><span class="nx">template</span><span class="p">()</span> <span class="p">},</span> <span class="p">{</span> <span class="na">root</span><span class="p">:</span> <span class="nx">el</span> <span class="p">})</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">msg</span> <span class="o">=</span> <span class="s1">'hello'</span>
  <span class="p">}</span>
  <span class="nx">bye</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">msg</span> <span class="o">=</span> <span class="s1">'goodbye'</span>
  <span class="p">}</span>
  <span class="kr">static</span> <span class="nx">template</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s2">`&lt;p onclick="{ bye }"&gt;{ msg }&lt;/p&gt;`</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">new</span> <span class="nx">MyTag</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">'my-div'</span><span class="p">)).</span><span class="nx">mount</span><span class="p">()</span>
</code></pre></div></div>

<p>Метод <code class="highlighter-rouge">riot.Tag</code> не рекомендуется использовать. Его следует использовать только в том случае, если вам не хватает вышеописанных методов.</p>