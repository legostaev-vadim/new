<h1 id="riot-vs-react--polymer">
  <strong>Riot</strong> vs <strong>React</strong> &amp; <strong>Polymer</strong>
</h1>

<p>And how Riot differs from its closest cousins.</p>

<h2 id="react">React</h2>

<p>Riot is inspired by React and from the idea of “cohesion”. According to Facebook developers:</p>

<blockquote>
  <p>“Templates separate technologies, not concerns.”</p>
</blockquote>

<p>We respect this insight. The goal is to build reusable components instead of templates. By separating logic from the templates we are actually keeping out things that should be together.</p>

<p>By combining these related technologies together under the same component the system becomes cleaner. We respect React because of this important insight.</p>

<h3 id="react-syntax">React syntax</h3>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">React</span> <span class="k">from</span> <span class="s1">'react'</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">render</span> <span class="p">}</span> <span class="k">from</span> <span class="s1">'react-dom'</span>

<span class="kd">class</span> <span class="nx">Todo</span> <span class="kd">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
  <span class="nx">state</span> <span class="o">=</span> <span class="p">{</span> <span class="na">items</span><span class="p">:</span> <span class="p">[],</span> <span class="na">value</span><span class="p">:</span> <span class="s1">''</span> <span class="p">}</span>
  <span class="nx">handleSubmit</span> <span class="o">=</span> <span class="nx">e</span> <span class="o">=&gt;</span>
    <span class="nx">e</span><span class="p">.</span><span class="nx">preventDefault</span><span class="p">()</span> <span class="o">||</span> <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span> <span class="na">items</span><span class="p">:</span> <span class="p">[...</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">items</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">value</span><span class="p">],</span> <span class="na">value</span><span class="p">:</span> <span class="s1">''</span> <span class="p">})</span>
  <span class="nx">handleChange</span> <span class="o">=</span> <span class="nx">e</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span> <span class="na">value</span><span class="p">:</span> <span class="nx">e</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">value</span> <span class="p">})</span>
  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span>
      <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="nx">h3</span><span class="o">&gt;</span><span class="nx">TODO</span><span class="o">&lt;</span><span class="sr">/h3</span><span class="err">&gt;
</span>        <span class="o">&lt;</span><span class="nx">ul</span><span class="o">&gt;</span>
          <span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">item</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="o">&lt;</span><span class="nx">li</span> <span class="nx">key</span><span class="o">=</span><span class="p">{</span><span class="nx">i</span><span class="p">}</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">item</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/li&gt;</span><span class="se">)</span><span class="err">}
</span>        <span class="o">&lt;</span><span class="sr">/ul</span><span class="err">&gt;
</span>        <span class="o">&lt;</span><span class="nx">form</span> <span class="nx">onSubmit</span><span class="o">=</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">handleSubmit</span><span class="p">}</span><span class="o">&gt;</span>
          <span class="o">&lt;</span><span class="nx">input</span> <span class="nx">value</span><span class="o">=</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">value</span><span class="p">}</span> <span class="nx">onChange</span><span class="o">=</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">handleChange</span><span class="p">}</span> <span class="sr">/</span><span class="err">&gt;
</span>          <span class="o">&lt;</span><span class="nx">button</span><span class="o">&gt;</span><span class="nx">Add</span> <span class="err">#</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nx">length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span>        <span class="o">&lt;</span><span class="sr">/form</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>    <span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">render</span><span class="p">(</span><span class="o">&lt;</span><span class="nx">Todo</span> <span class="o">/&gt;</span><span class="p">,</span> <span class="nx">mountNode</span><span class="p">)</span>
</code></pre></div></div>

<p>JSX is mixture of HTML and JavaScript. You can include HTML anywhere on the component; inside methods and in property assignments.</p>

<h3 id="riot-syntax">Riot syntax</h3>

<p>Here is the above thing with Riot:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;todo&gt;</span>
  <span class="nt">&lt;h3&gt;</span>TODO<span class="nt">&lt;/h3&gt;</span>

  <span class="nt">&lt;ul&gt;</span>
    <span class="nt">&lt;li</span> <span class="na">each=</span><span class="s">{</span> <span class="na">item</span><span class="err">,</span> <span class="na">i</span> <span class="na">in</span> <span class="na">items</span> <span class="err">}</span><span class="nt">&gt;</span>{ item }<span class="nt">&lt;/li&gt;</span>
  <span class="nt">&lt;/ul&gt;</span>

  <span class="nt">&lt;form</span> <span class="na">onsubmit=</span><span class="s">{</span> <span class="na">handleSubmit</span> <span class="err">}</span><span class="nt">&gt;</span>
    <span class="nt">&lt;input</span> <span class="na">ref=</span><span class="s">"input"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;button&gt;</span>Add #{ items.length + 1 }<span class="nt">&lt;/button&gt;</span>
  <span class="nt">&lt;/form&gt;</span>

  this.items = []

  handleSubmit(e) {
    e.preventDefault()
    var input = this.refs.input
    this.items.push(input.value)
    input.value = ''
  }
<span class="nt">&lt;/todo&gt;</span>
</code></pre></div></div>

<p>And this is how the above tag is mounted on a page:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;todo&gt;&lt;/todo&gt;</span>

<span class="nt">&lt;script&gt;</span><span class="nx">riot</span><span class="p">.</span><span class="nx">mount</span><span class="p">(</span><span class="s1">'todo'</span><span class="p">)</span><span class="nt">&lt;/script&gt;</span>
</code></pre></div></div>

<h3 id="same-same--but-different">Same, same — but different</h3>

<p>In Riot HTML and JavaScript appear much more familiar. Both are under the same component, but neatly separated from each other. The HTML can be mixed with JavaScript expressions.</p>

<p>No proprietary stuff, except the notation of enclosing expressions inside curly braces.</p>

<p>You see less boilerplate. Less brackets, commas, system properties and method names. Strings can be interpolated: <code class="highlighter-rouge">"Hello {world}"</code> instead of <code class="highlighter-rouge">"Hello " + this.state.world</code> and methods can be defined with compact ES6 syntax. Just less everything.</p>

<p>We think Riot syntax is the cleanest way to separate layout and logic while enjoying the benefits of isolated reusable components.</p>

<h3 id="virtual-dom-vs-expressions-binding">Virtual DOM vs expressions binding</h3>

<p>When a component is initialized React creates its Virtual DOM, Riot on the other hand traverses just a DOM tree.</p>

<p>Riot takes the expressions from the tree and stores them in an array. Each expression has a pointer to a DOM node. On each run these expressions are evaluated and compared to the values in the DOM. When a value has changed the corresponding DOM node is updated.</p>

<p>Since these expressions can be cached an update cycle is very fast. Going through 100 or 1000 expressions usually takes 1ms or less.</p>

<p>The React sync algorithm is much more complex since the HTML layout can change randomly after each update. Given the enormous challenge, Facebook developers did an impressive job with it.</p>

<p>We saw that the complex diffing can be avoided.</p>

<p>In Riot the HTML structure is fixed. Only loops and conditionals can add and remove elements. But a <code class="highlighter-rouge">div</code> cannot be converted to a <code class="highlighter-rouge">label</code> for example. Riot only updates the expressions without complex subtree replacements.</p>

<h3 id="flux-and-routing">Flux and routing</h3>

<p>React deals with the UI only, which is a good thing. All great software projects have a sharp focus.</p>

<p>Facebook recommends to use <a href="http://facebook.github.io/flux/docs/overview.html">Flux</a> to structure the client-side code. It’s more of a pattern than a framework and is packed with great ideas.</p>

<p>Riot comes bundled with custom tags, an event emitter (observable) and an optional router. We believe that these are the fundamental building blocks of client side applications. Events bring modularity, a router takes care of the URL and the back button and custom tags take care of the user interface.</p>

<p>Just like Flux, Riot is flexible and leaves the bigger architectural decisions for the developer. It’s just a library to help you achieve the goal.</p>

<p>You can build a Flux-like system by using Riot’s observable and router. In fact such thing <a href="https://github.com/jimsparkman/RiotControl">already exists</a>.</p>

<h3 id="3x-bigger">3x bigger</h3>

<p>React (v16.4.0) is 3x bigger than Riot.</p>

<p><small><em>react.min.js</em> – 33.27KB (gzip)</small>
<span class="bar red"></span></p>

<p><small><em>riot.min.js</em> – <span class="riot-size">10.85KB (gzip)</span></small>
<span class="bar blue" style="width: 32.61196272918545%"></span></p>

<p><br></p>

<p>The recommended React router (v4.1.1) is 6x larger than Riot router.</p>

<p><small><em>react-router.min.js</em> – 10.95KB (gzip)</small>
<span class="bar red"></span></p>

<p><small><em>react-mini-router.min.js</em> – 4.52KB (gzip)</small>
<span class="bar red" style="width: 41.278538812785385%"></span></p>

<p><small><em>riot.route.min.js</em> – 1.77KB (gzip)</small>
<span class="bar blue" style="width:16.164383561643834%"></span></p>

<p>Admittedly this router comparison is a bit unfair because <a href="https://github.com/rackt/react-router">react-router</a> has a lot more features. But the above chart clearly highlights the goal of Riot: to provide the most minimalistic API for the job.</p>

<p>The React ecosystem is more frameworky and favors larger API surfaces. The bigger alternative is more popular than <a href="https://github.com/larrymyers/react-mini-router">react-mini-router</a> in the React community.</p>

<h2 id="polymer">Polymer</h2>

<p>Polymer takes the Web Component standard and makes it available for the latest browsers. This allows you to write custom tags in a standard manner.</p>

<p>Conceptually Riot is the same thing but there are differences:</p>

<ol>
  <li>
    <p>The Web Components syntax is experimental and complex.</p>
  </li>
  <li>
    <p>Riot updates only the elements that have changed resulting to less DOM operations.</p>
  </li>
  <li>
    <p>Individual components are imported with HTML <code class="highlighter-rouge">link rel="import"</code>. Polyfills must resort to queued up XHRs, which makes it painfully slow unless the dedicated <a href="https://github.com/polymer/vulcanize">vulcanize</a> tool is used. Riot tags are imported with <code class="highlighter-rouge">script src</code> and multiple tags can be combined with regular tooling.</p>
  </li>
  <li>
    <p>No ability to perform server side rendering.</p>
  </li>
</ol>

<h3 id="6x-bigger">6x bigger</h3>

<p>Polymer(v1.8.0) + WebComponents(v0.7.24) is 6x bigger than Riot</p>

<p><small><em>polymer.min.js</em> – 49.38KB (gzip)</small>
<span class="bar red"></span></p>

<p><small><em>riot.min.js</em> – <span class="riot-size">10.85KB (gzip)</span></small>
<span class="bar blue" style="width: 21.972458485216688%"></span></p>

<p>Web components are said to be the <a href="http://developer.telerik.com/featured/web-components-arent-ready-production-yet/">king of all polyfilling challenges</a> and this is why Polymer requires such a large amount of code.</p>

<h2 id="web-components">Web components</h2>

<p>Because web components is a standard it is ultimately the way to go. It will take <a href="http://caniuse.com/#search=web%20components">years</a>, but eventually the web will be full of these standard components.</p>

<p>Because of the complexity involved there is a high chance that these components are not used directly. There will be layers on top of web components. Just like we have jQuery today. Most people are not using the DOM directly.</p>

<p>Riot is one such abstraction. It provides an easy to use API that our applications can stick to. Once the web component specs evolve Riot can start using them <em>internally</em> if there are any true benefits, such as performance gains.</p>

<p>The goal of Riot is to make UI development as easy as possible. The current API is designed to withstand the constant flux of web technologies. Think of it as the “jQuery for web components” - it takes syntaxical shortcuts to achieve the same goal. It simplifies the overall experience of writing reusable components.</p>