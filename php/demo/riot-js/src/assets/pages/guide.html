<div id="tabs">
  <?php get_menu($tabsGuide); ?>
</div>

<h1>Пользовательские теги</h1>

<div id="toc"><p><a href="#example">Пример</a></p><p><a href="#tag-syntax">Синтаксис тегов</a></p><p><a href="#pre-processor">Препроцессор</a></p><p><a href="#tag-styling">Стили тегов</a></p><p><a href="#mounting">Монтирование</a></p><p><a href="#mixins">Примеси</a></p><p><a href="#expressions">Выражения</a></p><p><a href="#nested-tags">Вложенные теги</a></p><p><a href="#named-elements">Именованные элементы</a></p><p><a href="#event-handlers">Обработчики DOM-событий</a></p><p><a href="#conditionals">Условия</a></p><p><a href="#loops">Циклы</a></p><p><a href="#html-elements-as-tags">HTML-элементы как теги</a></p><p><a href="#server-side-rendering">Рендеринг на стороне сервера</a></p><p><a href="#riot-dom-caveats">Riot DOM Предостережения</a></p></div>

<h2 id="example">Пример</h2>

<p>Пользовательские теги в Riot - это основные строительные блоки для интерфейсов. Они берут на себя часть “представление” в приложении. Давайте начнём с TODO-приложения, чтобы осветить различный функционал Riot:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;todo&gt;</span>

  <span class="nt">&lt;h3&gt;</span>{ opts.title }<span class="nt">&lt;/h3&gt;</span>

  <span class="nt">&lt;ul&gt;</span>
    <span class="nt">&lt;li</span> <span class="na">each=</span><span class="s">{</span> <span class="na">items</span> <span class="err">}</span><span class="nt">&gt;</span>
      <span class="nt">&lt;label</span> <span class="na">class=</span><span class="s">{</span> <span class="na">completed:</span> <span class="na">done</span> <span class="err">}</span><span class="nt">&gt;</span>
        <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">"checkbox"</span> <span class="na">checked=</span><span class="s">{</span> <span class="na">done</span> <span class="err">}</span> <span class="na">onclick=</span><span class="s">{</span> <span class="na">parent</span><span class="err">.</span><span class="na">toggle</span> <span class="err">}</span><span class="nt">&gt;</span> { title }
      <span class="nt">&lt;/label&gt;</span>
    <span class="nt">&lt;/li&gt;</span>
  <span class="nt">&lt;/ul&gt;</span>

  <span class="nt">&lt;form</span> <span class="na">onsubmit=</span><span class="s">{</span> <span class="na">add</span> <span class="err">}</span><span class="nt">&gt;</span>
    <span class="nt">&lt;input</span> <span class="na">ref=</span><span class="s">"input"</span> <span class="na">onkeyup=</span><span class="s">{</span> <span class="na">edit</span> <span class="err">}</span><span class="nt">&gt;</span>
    <span class="nt">&lt;button</span> <span class="na">disabled=</span><span class="s">{</span> <span class="err">!</span><span class="na">text</span> <span class="err">}</span><span class="nt">&gt;</span>Add #{ items.length + 1 }<span class="nt">&lt;/button&gt;</span>
  <span class="nt">&lt;/form&gt;</span>

  <span class="nt">&lt;script&gt;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">items</span> <span class="o">=</span> <span class="nx">opts</span><span class="p">.</span><span class="nx">items</span>

    <span class="nx">edit</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">text</span> <span class="o">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">value</span>
    <span class="p">}</span>

    <span class="nx">add</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">e</span><span class="p">.</span><span class="nx">preventDefault</span><span class="p">()</span>
      <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">text</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span> <span class="na">title</span><span class="p">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">text</span> <span class="p">})</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">text</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">refs</span><span class="p">.</span><span class="nx">input</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="s1">''</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="nx">toggle</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">item</span> <span class="o">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">item</span>
      <span class="nx">item</span><span class="p">.</span><span class="nx">done</span> <span class="o">=</span> <span class="o">!</span><span class="nx">item</span><span class="p">.</span><span class="nx">done</span>
    <span class="p">}</span>
  <span class="nt">&lt;/script&gt;</span>

<span class="nt">&lt;/todo&gt;</span>
</code></pre></div></div>

<p>Пользовательские теги <a href="guide-compiler">компилируются</a> в JavaScript.</p>

<p>Вы можете <a href="https://riot.js.org/examples/plunker/?app=todo-app">увидеть пример</a>, изучить <a href="https://github.com/riot/examples/tree/gh-pages/todo-app">исходный код</a> или скачать <a href="https://github.com/riot/examples/archive/gh-pages.zip">zip</a>.</p>

<h2 id="tag-syntax">Синтаксис тегов</h2>

<p>Теги Riot - это сочетание шаблона (HTML) и логики (JavaScript). Вот основные правила:</p>

<ul>
  <li>Сначала описывается HTML, затем следует логика, которая опционально заключается в тег <code class="highlighter-rouge">&lt;script&gt;</code>.</li>
  <li>Если не использовать опциональный тег <code class="highlighter-rouge">&lt;script&gt;</code>, то JavaScript начинается там, где заканчивается последний HTML-тег внутри пользовательского тега.</li>
  <li>Пользовательские теги могут быть пустыми, содержащими только HTML или только JavaScript.</li>
  <li>Кавычки писать не обязательно: <code class="highlighter-rouge">&lt;foo bar={ baz }&gt;</code> всё равно, что <code class="highlighter-rouge">&lt;foo bar="{ baz }"&gt;</code>.</li>
  <li>Поддерживается написание методов в синтаксисе ES6: <code class="highlighter-rouge">methodName()</code> всё равно, что <code class="highlighter-rouge">this.methodName = function()</code> и <code class="highlighter-rouge">this</code> всегда ссылается на тег.</li>
  <li>Доступен короткий синтаксис в выражениях: <code class="highlighter-rouge">class={ completed: done }</code> рендерится как <code class="highlighter-rouge">class="completed"</code> если <code class="highlighter-rouge">done</code> равен true.</li>
  <li>Булевые атрибуты (checked, selected и т.д.) игнорируются, если выражение равно false: <code class="highlighter-rouge">&lt;input checked={ undefined }&gt;</code> становится <code class="highlighter-rouge">&lt;input&gt;</code>.</li>
  <li>Все имена атрибутов <em>должны быть в нижнем регистре</em>. В соответствии со спецификациями браузеров.</li>
  <li>Поддерживаются самозакрывающиеся теги: <code class="highlighter-rouge">&lt;div/&gt;</code> всё равно, что <code class="highlighter-rouge">&lt;div&gt;&lt;/div&gt;</code>. Но такие теги, как <code class="highlighter-rouge">&lt;br&gt;</code>, <code class="highlighter-rouge">&lt;hr&gt;</code>, <code class="highlighter-rouge">&lt;img&gt;</code> или <code class="highlighter-rouge">&lt;input&gt;</code> никогда не закрываются после компиляции.</li>
  <li>Пользовательские теги всегда должны быть закрыты (или должны закрывать сами себя).</li>
  <li>Стандартные HTML-теги (<code class="highlighter-rouge">label</code>, <code class="highlighter-rouge">table</code>, <code class="highlighter-rouge">a</code> и т.д) можно использовать, но этого делать не стоит.</li>
</ul>

<p>Пользовательские теги должны иметь правильный отступ при определении, другими словами, отступ открывающего пользовательского тега должен соответствовать оступу закрывающего, на любой глубине вложенности. Поэтому не рекомендуется смешивать символы табуляции и пробелов.</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- правильно --&gt;</span>
<span class="nt">&lt;my-tag&gt;</span>

<span class="nt">&lt;/my-tag&gt;</span>

<span class="c">&lt;!-- правильно --&gt;</span>
<span class="nt">&lt;my-tag&gt;&lt;/my-tag&gt;</span>

<span class="c">&lt;!-- вызовет ошибку из-за несоответствия отступов --&gt;</span>
<span class="nt">&lt;my-tag&gt;</span>

  <span class="nt">&lt;/my-tag&gt;</span>
</code></pre></div></div>

<h3 id="no-script-tag">Без тега <code class="highlighter-rouge">&lt;script&gt;</code></h3>

<p>Не обязательно всегда писать тег <code class="highlighter-rouge">&lt;script&gt;</code>:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;todo&gt;</span>

  <span class="c">&lt;!-- шаблон --&gt;</span>
  <span class="nt">&lt;h3&gt;</span>{ opts.title }<span class="nt">&lt;/h3&gt;</span>

  // логика
  this.items = [1, 2, 3]

<span class="nt">&lt;/todo&gt;</span>
</code></pre></div></div>
<p>В этом случае, логика начинается после последнего HTML тега. Это “открытый синтаксис”, он часто используется в примерах на этом сайте.</p>

<h2 id="pre-processor">Препроцессор</h2>

<p>Вы можете задать тип препроцессора через атрибут <code class="highlighter-rouge">type</code>. Например:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;my-tag&gt;</span>
  <span class="nt">&lt;script </span><span class="na">type=</span><span class="s">"coffee"</span><span class="nt">&gt;</span>
    <span class="err">#</span> <span class="nx">тут ваш coffeescript</span>
  <span class="nt">&lt;/script&gt;</span>
<span class="nt">&lt;/my-tag&gt;</span>
</code></pre></div></div>

<p>Сейчас доступны “coffee”, “typescript”, “es6” и “none”. Вы также можете добавить префикс “text/”, например “text/coffee”.</p>

<p>Подробности можно посмотреть <a href="guide-compiler#pre-processors">здесь</a>.</p>

<h2 id="tag-styling">Стили тегов</h2>

<p>Вы можете поместить <code class="highlighter-rouge">style</code> внутрь пользовательского тега. Riot.js автоматически вынесет содержимое в <code class="highlighter-rouge">&lt;head&gt;</code>. Это происходит один раз и независимо от того, сколько раз тег был инициализирован.</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;todo&gt;</span>

  <span class="c">&lt;!-- шаблон --&gt;</span>
  <span class="nt">&lt;h3&gt;</span>{ opts.title }<span class="nt">&lt;/h3&gt;</span>

  <span class="nt">&lt;style&gt;</span>
    <span class="nt">todo</span> <span class="p">{</span> <span class="nl">display</span><span class="p">:</span> <span class="nb">block</span> <span class="p">}</span>
    <span class="nt">todo</span> <span class="nt">h3</span> <span class="p">{</span> <span class="nl">font-size</span><span class="p">:</span> <span class="m">120%</span> <span class="p">}</span>
    <span class="c">/** другие стили **/</span>
  <span class="nt">&lt;/style&gt;</span>

<span class="nt">&lt;/todo&gt;</span>
</code></pre></div></div>

<h3 id="scoped-css">Локальные CSS</h3>

<p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:scope">Локальный css и псевдо-класс :scope</a> также доступен для всех браузеров. Riot.js имеет свою собственную пользовательскую реализацию в JS, которая не зависит от реализации браузера. Пример ниже эквивалентен первому. Обратите внимание, что в приведенном ниже примере используется <code class="highlighter-rouge">псевдо-класс :scope</code> вместо использования имени тега для применения стилей, как в примере выше.</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;todo&gt;</span>

  <span class="c">&lt;!-- шаблон --&gt;</span>
  <span class="nt">&lt;h3&gt;</span>{ opts.title }<span class="nt">&lt;/h3&gt;</span>

  <span class="nt">&lt;style&gt;</span>
    <span class="nd">:scope</span> <span class="p">{</span> <span class="nl">display</span><span class="p">:</span> <span class="nb">block</span> <span class="p">}</span>
    <span class="nt">h3</span> <span class="p">{</span> <span class="nl">font-size</span><span class="p">:</span> <span class="m">120%</span> <span class="p">}</span>
    <span class="c">/** другие стили **/</span>
  <span class="nt">&lt;/style&gt;</span>

<span class="nt">&lt;/todo&gt;</span>
</code></pre></div></div>

<p>Для того, чтобы проще было переопределять стили и использовать темы, вы можете указать где в <code class="highlighter-rouge">&lt;head&gt;</code> Riot должен поместить стили из пользовательских тегов:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;style </span><span class="na">type=</span><span class="s">"riot"</span><span class="nt">&gt;&lt;/style&gt;</span>
</code></pre></div></div>

<p>Примером использования может быть вставка стилей тегов после normalize.css, но перед темой CSS вашего веб-сайта, позволяющей переопределить стили тегов по умолчанию.</p>

<h2 id="mounting">Монтирование</h2>

<p>Теперь, когда у вас есть тег, вы можете примонтировать его на странице таким образом:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;body&gt;</span>

  <span class="c">&lt;!-- разместить пользовательский тег в любой части страницы --&gt;</span>
  <span class="nt">&lt;todo&gt;&lt;/todo&gt;</span>

  <span class="c">&lt;!-- подключить riot.js --&gt;</span>
  <span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"riot.min.js"</span><span class="nt">&gt;&lt;/script&gt;</span>

  <span class="c">&lt;!-- подключить тег javascript, сгенерированный с помощью компилятора riot --&gt;</span>
  <span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"todo.js"</span><span class="nt">&gt;&lt;/script&gt;</span>

  <span class="c">&lt;!-- монтировать тег --&gt;</span>
  <span class="nt">&lt;script&gt;</span><span class="nx">riot</span><span class="p">.</span><span class="nx">mount</span><span class="p">(</span><span class="s1">'todo'</span><span class="p">)</span><span class="nt">&lt;/script&gt;</span>

<span class="nt">&lt;/body&gt;</span>
</code></pre></div></div>

<p>Пользовательские теги внутри <code class="highlighter-rouge">body</code> должны закрываться, используя такой синтаксис: <code class="highlighter-rouge">&lt;todo&gt;&lt;/todo&gt;</code> и самозакрытие: <code class="highlighter-rouge">&lt;todo/&gt;</code> не поддерживается.</p>

<p>Немного наглядных примеров:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// монтируем все пользовательские теги на странице</span>
<span class="nx">riot</span><span class="p">.</span><span class="nx">mount</span><span class="p">(</span><span class="s1">'*'</span><span class="p">)</span>

<span class="c1">// монтируем элемент с определённым id</span>
<span class="nx">riot</span><span class="p">.</span><span class="nx">mount</span><span class="p">(</span><span class="s1">'#my-element'</span><span class="p">)</span>

<span class="c1">// монтируем выбранные элементы</span>
<span class="nx">riot</span><span class="p">.</span><span class="nx">mount</span><span class="p">(</span><span class="s1">'todo, forum, comments'</span><span class="p">)</span>
</code></pre></div></div>

<p>Один и тот же тег можно монтировать на странице множество раз.</p>

<h3 id="accessing-dom-elements">Доступ к элементам DOM</h3>

<p>Riot предоставляет вам доступ к элементам, которые имеют атрибуты <code class="highlighter-rouge">ref</code> через объект <code class="highlighter-rouge">this.refs</code>, и множество сокращенных свойств-методов, таких как атрибут <code class="highlighter-rouge">if="{...}"</code>, но иногда вам нужно сослаться на фрагменты HTML, которые не находятся внутри этих элементов.</p>

<h3 id="how-to-use-jquery-zepto-queryselector-etc">Как использовать jQuery, Zepto, querySelector, и т.д.</h3>
<p>Если вам нужно получить доступ к DOM внутри Riot, взгляните на <a href="#tag-lifecycle">жизненный цикл тегов</a> и обратите внимание, что элементы DOM не будут созданы до вызова метода <code class="highlighter-rouge">mount</code>. Учтите это при обращении к DOM-элементам из сторонних библиотек, так как это может стать причиной ошибок.</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;example-tag&gt;</span>
  <span class="nt">&lt;p</span> <span class="na">id=</span><span class="s">"findMe"</span><span class="nt">&gt;</span>Я существую?<span class="nt">&lt;/p&gt;</span>

  <span class="nt">&lt;script&gt;</span>
  <span class="kd">var</span> <span class="nx">test1</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">'findMe'</span><span class="p">)</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'test1'</span><span class="p">,</span> <span class="nx">test1</span><span class="p">)</span>  <span class="c1">// Ошибка</span>

  <span class="k">this</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'update'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="kd">var</span> <span class="nx">test2</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">'findMe'</span><span class="p">)</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'test2'</span><span class="p">,</span> <span class="nx">test2</span><span class="p">)</span> <span class="c1">// Успешно, срабатывает при каждом обновлении</span>
  <span class="p">})</span>

  <span class="k">this</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'mount'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="kd">var</span> <span class="nx">test3</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">'findMe'</span><span class="p">)</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'test3'</span><span class="p">,</span> <span class="nx">test3</span><span class="p">)</span> <span class="c1">// Успешно, сработает один раз (при монтировании)</span>
  <span class="p">})</span>
  <span class="nt">&lt;/script&gt;</span>
<span class="nt">&lt;/example-tag&gt;</span>
</code></pre></div></div>

<h3 id="contexted-dom-query">Контекстные запросы к DOM</h3>

<p>Теперь, когда мы знаем, как получить элементы DOM используя события <code class="highlighter-rouge">update</code> или <code class="highlighter-rouge">mount</code>, мы можем улучшить этот процесс, если добавим в качестве контекста к запросам наших элементов <code class="highlighter-rouge">корневой (root) элемент</code> создаваемого нами тега riot.</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;example-tag&gt;</span>
  <span class="nt">&lt;p</span> <span class="na">id=</span><span class="s">"findMe"</span><span class="nt">&gt;</span>Я существую?<span class="nt">&lt;/p&gt;</span>
  <span class="nt">&lt;p&gt;</span>Это реальная жизнь?<span class="nt">&lt;/p&gt;</span>
  <span class="nt">&lt;p&gt;</span>Или фантазия?<span class="nt">&lt;/p&gt;</span>

  <span class="nt">&lt;script&gt;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'mount'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="c1">// Контекстный jQuery</span>
    <span class="nx">$</span><span class="p">(</span><span class="s1">'p'</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">root</span><span class="p">)</span>

    <span class="c1">// Контекстный Query Selector</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">root</span><span class="p">.</span><span class="nx">querySelectorAll</span><span class="p">(</span><span class="s1">'p'</span><span class="p">)</span>
  <span class="p">})</span>
  <span class="nt">&lt;/script&gt;</span>
<span class="nt">&lt;/example-tag&gt;</span>
</code></pre></div></div>

<h3 id="options">Параметры</h3>

<p>Вы можете передать параметры для тегов во втором аргументе</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;script&gt;</span>
<span class="nx">riot</span><span class="p">.</span><span class="nx">mount</span><span class="p">(</span><span class="s1">'todo'</span><span class="p">,</span> <span class="p">{</span> <span class="na">title</span><span class="p">:</span> <span class="s1">'My TODO app'</span><span class="p">,</span> <span class="na">items</span><span class="p">:</span> <span class="p">[</span> <span class="p">...</span> <span class="p">]</span> <span class="p">})</span>
<span class="nt">&lt;/script&gt;</span>
</code></pre></div></div>

<p>Передаваемые данные могут быть чем угодно, начиная от простого объекта до полномасштабного API приложения. Или это может быть хранилище Flux. Это зависит от архитектуры приложения.</p>

<p>Внутри тега можно получить параметры через <code class="highlighter-rouge">opts</code>:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;my-tag&gt;</span>

  <span class="c">&lt;!-- параметры в HTML --&gt;</span>
  <span class="nt">&lt;h3&gt;</span>{ opts.title }<span class="nt">&lt;/h3&gt;</span>

  // параметры в JavaScript
  var title = opts.title

<span class="nt">&lt;/my-tag&gt;</span>
</code></pre></div></div>

<h3 id="tag-lifecycle">Жизненный цикл тегов</h3>

<p>Тег создаётся в такой последовательности:</p>

<ol>
  <li>Тег инициaлизируется</li>
  <li>Выполняется JavaScript-логика тега</li>
  <li>Вычисляются HTML выражения</li>
  <li>Тег монтируется в приложение и вызывается метод “mount”</li>
</ol>

<p>После того, как тег был примонтирован, выражения вычисляются следующим образом:</p>

<ol>
  <li>Автоматически, после вызова обработчика события (если вы не установите e.preventUpdate в значение true в обработчике событий). Например, вызов метода <code class="highlighter-rouge">toggle</code> в приведенном выше примере.</li>
  <li>Когда вызывается <code class="highlighter-rouge">this.update()</code> для текущего экземпляра тега.</li>
  <li>Когда вызывается <code class="highlighter-rouge">this.update()</code> в каком-нибудь из родительских тегов. Обновления происходят сверху вниз, от родительских тегов к дочерним.</li>
  <li>Когда вызывается <code class="highlighter-rouge">riot.update()</code>, который глобально обновляет все выражения на странице.</li>
</ol>

<p>Метод “update” автоматически вызывается каждый раз, когда тег обновляется.</p>

<p>Так как значения вычисляются перед монтированием, то не возникает сюрпризов, вроде http-запросов на несуществующий ресурс: <code class="highlighter-rouge">&lt;img src={ src }&gt;</code>.</p>

<h3 id="listening-to-lifecycle-events">Прослушивание событий тега</h3>

<p>Вы можете прослушивать дефолтные события тегов следующим образом:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">todo</span><span class="o">&gt;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'before-mount'</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// перед тем, как тег будет примонтирован</span>
  <span class="p">})</span>

  <span class="k">this</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'mount'</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// сразу после того, как тег будет примонтирован</span>
  <span class="p">})</span>

  <span class="k">this</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'update'</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// позволяет изменять данные тега перед обновлением</span>
  <span class="p">})</span>

  <span class="k">this</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'updated'</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// сразу после того, как тег обновился</span>
  <span class="p">})</span>

  <span class="k">this</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'before-unmount'</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// перед тем, как тег отмонтируется</span>
  <span class="p">})</span>

  <span class="k">this</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'unmount'</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// когда тег открепляется от страницы</span>
  <span class="p">})</span>

  <span class="c1">// нужны сразу все события?</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'*'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">eventName</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">info</span><span class="p">(</span><span class="nx">eventName</span><span class="p">)</span>
  <span class="p">})</span>

<span class="o">&lt;</span><span class="sr">/todo</span><span class="err">&gt;
</span></code></pre></div></div>

<p>Вы можете использовать множество обработчиков для одного и того же события. Смотри API <a href="api-observable">наблюдателя</a> для более подробной информации.</p>

<h2 id="mixins">Примеси (Mixins)</h2>

<p>Примеси предоставляют простой способ делиться функционалом между тегами. Когда тег скомпилирован с помощью riot, все определенные примеси добавляются и доступны для использования в теге.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">OptsMixin</span> <span class="o">=</span> <span class="p">{</span>
  <span class="c1">// аргумент `opts` является объектом свойств, получаемый тегом</span>
  <span class="na">init</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">opts</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'updated'</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'Updated!'</span><span class="p">)</span> <span class="p">})</span>
  <span class="p">},</span>

  <span class="na">getOpts</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">opts</span>
  <span class="p">},</span>

  <span class="na">setOpts</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">opts</span><span class="p">,</span> <span class="nx">update</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">opts</span> <span class="o">=</span> <span class="nx">opts</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">update</span><span class="p">)</span> <span class="k">this</span><span class="p">.</span><span class="nx">update</span><span class="p">()</span>
    <span class="k">return</span> <span class="k">this</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="o">&lt;</span><span class="nx">my</span><span class="o">-</span><span class="nx">tag</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nx">h1</span><span class="o">&gt;</span><span class="p">{</span> <span class="nx">opts</span><span class="p">.</span><span class="nx">title</span> <span class="p">}</span><span class="o">&lt;</span><span class="sr">/h1</span><span class="err">&gt;
</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">mixin</span><span class="p">(</span><span class="nx">OptsMixin</span><span class="p">)</span>
<span class="o">&lt;</span><span class="sr">/my-tag</span><span class="err">&gt;
</span></code></pre></div></div>

<p>В этом примере, любой экземпляр тега <code class="highlighter-rouge">my-tag</code> получает примесь <code class="highlighter-rouge">OptsMixin</code>, которая позволяет использовать методы <code class="highlighter-rouge">getOpts</code> и <code class="highlighter-rouge">setOpts</code>. Специальный метод <code class="highlighter-rouge">init</code> вызывается, когда примесь загружается в тег (<code class="highlighter-rouge">init</code> не доступен из тега).</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">my_tag_instance</span> <span class="o">=</span> <span class="nx">riot</span><span class="p">.</span><span class="nx">mount</span><span class="p">(</span><span class="s1">'my-tag'</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">my_tag_instance</span><span class="p">.</span><span class="nx">getOpts</span><span class="p">())</span> <span class="c1">// выведет список всех параметров доступных в теге</span>
</code></pre></div></div>

<p>Теги могут принимать любой объект – <code class="highlighter-rouge">{'key': 'val'}</code> <code class="highlighter-rouge">var mix = new function(...)</code> – и выдают ошибку, когда получают любой другой тип.</p>

<p>Тег <code class="highlighter-rouge">my-tag</code> теперь имеет метод <code class="highlighter-rouge">getId</code> вместе со всем, что определено в <code class="highlighter-rouge">OptsMixin</code>, кроме функции <code class="highlighter-rouge">init</code>.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">IdMixin</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">getId</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_id</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">id_mixin_instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">IdMixin</span><span class="p">()</span>

<span class="o">&lt;</span><span class="nx">my</span><span class="o">-</span><span class="nx">tag</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nx">h1</span><span class="o">&gt;</span><span class="p">{</span> <span class="nx">opts</span><span class="p">.</span><span class="nx">title</span> <span class="p">}</span><span class="o">&lt;</span><span class="sr">/h1</span><span class="err">&gt;
</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">mixin</span><span class="p">(</span><span class="nx">OptsMixin</span><span class="p">,</span> <span class="nx">id_mixin_instance</span><span class="p">)</span>
<span class="o">&lt;</span><span class="sr">/my-tag</span><span class="err">&gt;
</span></code></pre></div></div>

<p>Будучи определена на уровне тегов, примесь может не только расширить функциональность вашего тега, но также позволяет создавать повторяемые интерфейсы. Каждый раз, когда тег монтируется, экземпляр тега будет иметь код из примеси.</p>

<h3 id="shared-mixins">Общие примеси</h3>

<p>Для обмена примесями между тегами или проектами, существует <code class="highlighter-rouge">riot.mixin</code>. Вы можете зарегистрировать вашу примесь следующим образом:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">riot</span><span class="p">.</span><span class="nx">mixin</span><span class="p">(</span><span class="s1">'mixinName'</span><span class="p">,</span> <span class="nx">mixinObject</span><span class="p">)</span>
</code></pre></div></div>

<p>Для того, чтобы загрузить вашу примесь в тег, используйте метод <code class="highlighter-rouge">mixin()</code> с указанием имени примеси:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;my-tag&gt;</span>
  <span class="nt">&lt;h1&gt;</span>{ opts.title }<span class="nt">&lt;/h1&gt;</span>

  this.mixin('mixinName')
<span class="nt">&lt;/my-tag&gt;</span>
</code></pre></div></div>

<h3 id="global-mixins">Глобальные примеси</h3>

<p>Если вам нужно добавить какую-либо функциональность ко всем вашим тегам, вы можете зарегистрировать глобальную примесь следующим образом:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Необходимо зарегистрировать до монтирования тегов</span>
<span class="nx">riot</span><span class="p">.</span><span class="nx">mixin</span><span class="p">(</span><span class="nx">mixinObject</span><span class="p">)</span>
</code></pre></div></div>

<p>В отличие от общих примесей, глобальные загружаются автоматически во все смонтированные теги. Так что используйте это осторожно!</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">riot</span><span class="p">.</span><span class="nx">mixin</span><span class="p">(</span><span class="s1">'globalMixinOne'</span><span class="p">,</span> <span class="nx">mixinObjectOne</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">riot</span><span class="p">.</span><span class="nx">mixin</span><span class="p">(</span><span class="s1">'globalMixinOne'</span><span class="p">)</span> <span class="o">===</span> <span class="nx">mixinObjectOne</span><span class="p">)</span> <span class="c1">// true</span>
</code></pre></div></div>

<p>Иногда вам может понадобиться получить объект примеси, поэтому вы можете установить оъект глобальной примеси по имени. В этом случае, третий логический параметр указывает на то, что эта примесь является не общей, а глобальной.</p>

<h2 id="expressions">Выражения</h2>

<p>В HTML-шаблоне можно использовать выражения, заключённые в фигурные скобки:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span> <span class="cm">/* здесь размещается выражение */</span> <span class="p">}</span>
</code></pre></div></div>

<p>Выражения могут устанавливать атрибуты или вложенные текстовые узлы:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;h3</span> <span class="na">id=</span><span class="s">{</span> <span class="err">/*</span> <span class="err">выражение</span> <span class="err">атрибута</span> <span class="err">*/</span> <span class="err">}</span><span class="nt">&gt;</span>
  { /* вложенное выражение */ }
<span class="nt">&lt;/h3&gt;</span>
</code></pre></div></div>

<p>Выражения на все 100% - JavaScript. Вот несколько примеров:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span> <span class="nx">title</span> <span class="o">||</span> <span class="s1">'Untitled'</span> <span class="p">}</span>
<span class="p">{</span> <span class="nx">results</span> <span class="p">?</span> <span class="s1">'ready'</span> <span class="p">:</span> <span class="s1">'loading'</span> <span class="p">}</span>
<span class="p">{</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">()</span> <span class="p">}</span>
<span class="p">{</span> <span class="nx">message</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">140</span> <span class="o">&amp;&amp;</span> <span class="s1">'Message is too long'</span> <span class="p">}</span>
<span class="p">{</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">round</span><span class="p">(</span><span class="nx">rating</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div></div>

<p>Выражения нужны для того, чтобы сохранять HTML как можно более чистым и очевидным. Если ваши выражения слишком громоздки, попробуйте вынести часть логики в обработчик события “update”. Например:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;my-tag&gt;</span>

  <span class="c">&lt;!-- `val` будет вычислено ниже .. --&gt;</span>
  <span class="nt">&lt;p&gt;</span>{ val }<span class="nt">&lt;/p&gt;</span>

  // ..при каждом обновлении
  this.on('update', function() {
    this.val = some / complex * expression ^ here
  })
<span class="nt">&lt;/my-tag&gt;</span>
</code></pre></div></div>

<h3 id="boolean-attributes">Булевые атрибуты</h3>

<p>Булевые атрибуты (checked, selected etc..) игнорируются, если значение выражения ложно:</p>

<p><code class="highlighter-rouge">&lt;input checked={ null }&gt;</code> становится <code class="highlighter-rouge">&lt;input&gt;</code>.</p>

<p>Стандарт W3C гласит, что булевый атрибут считается установленным, если присутствует среди атрибутов тега, каким бы ни было его значение, даже <code class="highlighter-rouge">false</code>.</p>

<p>Нижеследующие выражение работать не будет:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">"checkbox"</span> <span class="err">{</span> <span class="na">true</span> <span class="err">?</span> <span class="err">'</span><span class="na">checked</span><span class="err">'</span> <span class="na">:</span> <span class="err">''}</span><span class="nt">&gt;</span>
</code></pre></div></div>

<p>так как допустимы только атрибуты и вложенные текстовые выражения. Riot распознаёт 44 булевых атрибута.</p>

<h3 id="class-shorthand">Сокращённая запись CSS-классов</h3>

<p>В Riot есть специальный синтаксис для имён CSS-классов:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;p</span> <span class="na">class=</span><span class="s">{</span> <span class="na">foo:</span> <span class="na">true</span><span class="err">,</span> <span class="na">bar:</span> <span class="na">0</span><span class="err">,</span> <span class="na">baz:</span> <span class="na">new</span> <span class="na">Date</span><span class="err">(),</span> <span class="na">zorro:</span> <span class="err">'</span><span class="na">a</span> <span class="na">value</span><span class="err">'</span> <span class="err">}</span><span class="nt">&gt;&lt;/p&gt;</span>
</code></pre></div></div>

<p>элемент будет иметь классы <code class="highlighter-rouge">foo baz zorro</code>. Если значение свойства верно, то название свойства отображается в списке классов. Конечно, вы можете использовать эту нотацию в других местах, кроме имён классов, если вы найдете подходящий вариант использования.</p>

<h3 id="class-object-expressions">Передача классов в объекте</h3>

<p><span class="tag red">&gt;=3.4.0</span></p>

<p>Вы также можете использовать объект для определения классов ваших элементов. Например:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;my-tag&gt;</span>
  <span class="nt">&lt;p</span> <span class="na">class=</span><span class="s">{</span> <span class="na">classes</span> <span class="err">}</span><span class="nt">&gt;&lt;/p&gt;</span>
  <span class="nt">&lt;script&gt;</span>
    <span class="nx">hasAnimation</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kc">true</span>
    <span class="p">}</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">randomNumber</span> <span class="o">=</span> <span class="mi">5</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">classes</span> <span class="o">=</span> <span class="p">{</span>
      <span class="na">foo</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
      <span class="na">bar</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
      <span class="na">number</span><span class="p">:</span> <span class="s1">'3 &gt; randomNumber'</span><span class="p">,</span>
      <span class="na">animated</span><span class="p">:</span> <span class="s1">'hasAnimation()'</span><span class="p">,</span> <span class="c1">// будьте осторожны, методы должны быть заданы как строки</span>
      <span class="na">baz</span><span class="p">:</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">(),</span>
      <span class="na">zorro</span><span class="p">:</span> <span class="s1">'a value'</span>
    <span class="p">}</span>
  <span class="nt">&lt;/script&gt;</span>
<span class="nt">&lt;/my-tag&gt;</span>
</code></pre></div></div>

<p>элемент будет иметь классы <code class="highlighter-rouge">foo number animated baz zorro</code>. Riot преобразует объект к строке и отобразит все ключи, имеющие истинные значения.</p>

<h3 id="style-object-expressions">Передача стилей в объекте</h3>

<p><span class="tag red">&gt;=3.4.0</span></p>

<p>Встроенные стили можно передать в виде объекта, и Riot автоматически преобразует их в строки. Например:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;my-tag&gt;</span>
  <span class="nt">&lt;p</span> <span class="na">style=</span><span class="s">{</span> <span class="na">styles</span> <span class="err">}</span><span class="nt">&gt;&lt;/p&gt;</span>
  <span class="nt">&lt;script&gt;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">styles</span> <span class="o">=</span> <span class="p">{</span>
      <span class="na">color</span><span class="p">:</span> <span class="s1">'red'</span><span class="p">,</span>
      <span class="na">height</span><span class="p">:</span> <span class="s1">'10rem'</span>
    <span class="p">}</span>
  <span class="nt">&lt;/script&gt;</span>
<span class="nt">&lt;/my-tag&gt;</span>
</code></pre></div></div>

<p>элемент будет иметь стили <code class="highlighter-rouge">&lt;p style="color: red; height: 10rem"&gt;&lt;/p&gt;</code></p>

<h3 id="printing-brackets">Экранирование выражений</h3>

<p>Вы можете отобразить выражение как текст, если заэкранируете открывающую скобку:</p>

<p><code class="highlighter-rouge">\{ this is not evaluated }</code> выведет <code class="highlighter-rouge">{ this is not evaluated }</code></p>

<p>Обязательно избегайте скобок в любой ситуации, где они не должны вычисляться. Например, шаблон Regex, приведенный ниже, не сможет проверить предполагаемый ввод (любые два числовых символа) и вместо этого примет только один числовой символ, за которым следует число “2”:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;my-tag&gt;</span>
  <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">'text'</span> <span class="na">pattern=</span><span class="s">"\d{2}"</span><span class="nt">&gt;</span>
<span class="nt">&lt;/my-tag&gt;</span>
</code></pre></div></div>

<p>Правильной реализацией будет:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;my-tag&gt;</span>
  <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">'text'</span> <span class="na">pattern=</span><span class="s">"\d\{2}"</span><span class="nt">&gt;</span>
<span class="nt">&lt;/my-tag&gt;</span>
</code></pre></div></div>

<h3 id="customizing-curly-braces">Символы для выражений</h3>

<p>Вы можете задать символы, которые будут определять начало и конец выражения:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">riot</span><span class="p">.</span><span class="nx">settings</span><span class="p">.</span><span class="nx">brackets</span> <span class="o">=</span> <span class="s1">'${ }'</span>
<span class="nx">riot</span><span class="p">.</span><span class="nx">settings</span><span class="p">.</span><span class="nx">brackets</span> <span class="o">=</span> <span class="s1">'</span><span class="err">\</span><span class="s1">{</span><span class="err">\</span><span class="s1">{ }}'</span>
</code></pre></div></div>

<p>Они должны разделяться пробелом.</p>

<p>При использовании <a href="guide-compiler#pre-compilation">пре-компилятора</a>, вам стоит настроить <code class="highlighter-rouge">brackets</code>.</p>

<h3 id="etc">Прочее</h3>

<p>Выражения внутри <code class="highlighter-rouge">style</code> игнорируются.</p>

<h3 id="render-unescaped-html">Вывод HTML в выражениях</h3>

<p>Выражения могут выводить только текстовые значения без HTML. Однако, вы можете создать собственный тег, который будет это делать. Например:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;raw&gt;</span>
  <span class="nt">&lt;span&gt;&lt;/span&gt;</span>

  this.root.innerHTML = opts.content
<span class="nt">&lt;/raw&gt;</span>
</code></pre></div></div>

<p>Этот тег можно использовать в других тегах. Например:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;my-tag&gt;</span>
  <span class="nt">&lt;p&gt;</span>Here is some raw content: <span class="nt">&lt;raw</span> <span class="na">content=</span><span class="s">"{ html }"</span><span class="nt">/&gt;</span> <span class="nt">&lt;/p&gt;</span>

  this.html = 'Hello, <span class="nt">&lt;strong&gt;</span>world!<span class="nt">&lt;/strong&gt;</span>'
<span class="nt">&lt;/my-tag&gt;</span>
</code></pre></div></div>

<p><a href="http://jsfiddle.net/23g73yvx/">демо на jsfiddle</a></p>

<p><span class="tag red">warning</span> это может подвергнуть пользователя атакам XSS, поэтому убедитесь, что вы никогда не загружаете данные из ненадежного источника.</p>

<p>Обратите внимание, что в более практической ситуации, вам нужно будет указать событие  <code class="highlighter-rouge">update</code> вручную следующим образом, поскольку в шаблоне нет выражения для обновления (<code class="highlighter-rouge">&lt;span&gt;&lt;/span&gt;</code>).</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;raw&gt;</span>
  <span class="nt">&lt;span&gt;&lt;/span&gt;</span>

  this.innerHTML.root = opts.content
  this.on('update', function(){ this.root.innerHTML = opts.content });
<span class="nt">&lt;/raw&gt;</span>
</code></pre></div></div>

<p><a href="http://jsfiddle.net/7m3bvy1d/">демо на jsfiddle</a></p>

<h2 id="nested-tags">Вложенные теги</h2>

<p>Давайте создадим родительский тег <code class="highlighter-rouge">&lt;account&gt;</code> с вложенным тегом <code class="highlighter-rouge">&lt;subscription&gt;</code>:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;account&gt;</span>
  <span class="nt">&lt;subscription</span>  <span class="na">plan=</span><span class="s">{</span> <span class="na">opts</span><span class="err">.</span><span class="na">plan</span> <span class="err">}</span> <span class="na">show_details=</span><span class="s">"true"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/account&gt;</span>


<span class="nt">&lt;subscription&gt;</span>
  <span class="nt">&lt;h3&gt;</span>{ opts.plan.name }<span class="nt">&lt;/h3&gt;</span>

  // получить параметры
  var plan = opts.plan,
      show_details = opts.show_details

  // доступ к родительскому тегу
  var parent = this.parent

<span class="nt">&lt;/subscription&gt;</span>
</code></pre></div></div>

<p><span class="tag red">важно</span> Заметьте, что мы используем нижние подчёркивание <code class="highlighter-rouge">show_details</code> вместо camelCase. Это связано с тем, что браузеры автоматически конвертируют формат html в нижний регистр.</p>

<p>Затем мы монтируем <code class="highlighter-rouge">account</code> на страницу и передаём ему объект с параметром <code class="highlighter-rouge">plan</code>:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;body&gt;</span>
  <span class="nt">&lt;account&gt;&lt;/account&gt;</span>
<span class="nt">&lt;/body&gt;</span>

<span class="nt">&lt;script&gt;</span>
<span class="nx">riot</span><span class="p">.</span><span class="nx">mount</span><span class="p">(</span><span class="s1">'account'</span><span class="p">,</span> <span class="p">{</span> <span class="na">plan</span><span class="p">:</span> <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="s1">'small'</span><span class="p">,</span> <span class="na">term</span><span class="p">:</span> <span class="s1">'monthly'</span> <span class="p">}</span> <span class="p">})</span>
<span class="nt">&lt;/script&gt;</span>
</code></pre></div></div>

<p>Параметры родительского тега передаются с помощью метода <code class="highlighter-rouge">riot.mount</code>, а параметры дочернего тега передаются в атрибуте тега.</p>

<p><span class="tag red">важно</span> Вложенные теги всегда объявляются внутри родительского пользовательского тега. Они не инициализируются, если они определены на странице.</p>

<h3 id="nested-html">Внутренний HTML</h3>

<p>“Включение HTML” - это способ обработки внутреннего HTML на странице. Это достигается путём использования встроенного тега <code class="highlighter-rouge">&lt;yield&gt;</code>. Пример:</p>

<h3 id="tag-definition">Определение тега</h3>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;my-tag&gt;</span>
  <span class="nt">&lt;p&gt;</span>Hello <span class="nt">&lt;yield/&gt;&lt;/p&gt;</span>
  this.text = 'world'
<span class="nt">&lt;/my-tag&gt;</span>
</code></pre></div></div>

<h3 id="usage">Использование</h3>

<p>Пользовательский тег размещается на странице с внутренним HTML</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;my-tag&gt;</span>
  <span class="nt">&lt;b&gt;</span>{ text }<span class="nt">&lt;/b&gt;</span>
<span class="nt">&lt;/my-tag&gt;</span>
</code></pre></div></div>

<h3 id="result">Результат</h3>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;my-tag&gt;</span>
  <span class="nt">&lt;p&gt;</span>Hello <span class="nt">&lt;b&gt;</span>world<span class="nt">&lt;/b&gt;&lt;p&gt;</span>
<span class="nt">&lt;/my-tag&gt;</span>
</code></pre></div></div>

<p>Смотрите <a href="api#-yielding-nested-html">API документацию</a> для <code class="highlighter-rouge">yield</code>.</p>

<h2 id="named-elements">Именованные элементы</h2>

<p>Элементы с атрибутом <code class="highlighter-rouge">ref</code> автоматически привязываются к соответствующему параметру переменной <code class="highlighter-rouge">this.refs</code>, поэтому вы можете легко получить к ним доступ с помощью JavaScript:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;login&gt;</span>
  <span class="nt">&lt;form</span> <span class="na">ref=</span><span class="s">"login"</span> <span class="na">onsubmit=</span><span class="s">{</span> <span class="na">submit</span> <span class="err">}</span><span class="nt">&gt;</span>
    <span class="nt">&lt;input</span> <span class="na">ref=</span><span class="s">"username"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;input</span> <span class="na">ref=</span><span class="s">"password"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;button</span> <span class="na">ref=</span><span class="s">"submit"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;/form&gt;</span>

  // получить HTML-элементы выше
  submit(e) {
    var form = this.refs.login,
        username = this.refs.username.value,
        password = this.refs.password.value,
        button = this.refs.submit
  }

<span class="nt">&lt;/login&gt;</span>
</code></pre></div></div>

<p>Атрибут <code class="highlighter-rouge">refs</code> будет установлен при срабатывании события <code class="highlighter-rouge">mount</code>, поэтому вы можете получить доступ к коллекции элементов <code class="highlighter-rouge">this.refs</code> в <code class="highlighter-rouge">mount</code> (<code class="highlighter-rouge">this.on('mount', function() {...}) </code>) или в других обработчиках событий.</p>

<p><span class="tag red">&gt;=3.0</span></p>

<p>Если атрибут <code class="highlighter-rouge">ref</code> применяется к тегу Riot, он будет ссылаться на <a href="api#tag-instance">экземпляр тега</a>,  а не на элемент DOM, как в случае выше. Например:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;my-tag&gt;</span>
  <span class="nt">&lt;my-nested-tag</span> <span class="na">data-ref=</span><span class="s">"one"</span><span class="nt">&gt;&lt;/my-nested-tag&gt;</span>
  <span class="nt">&lt;div</span> <span class="na">data-ref=</span><span class="s">"two"</span><span class="nt">&gt;&lt;/div&gt;</span>  

  this.on('mount', function() {
    console.log(this.refs.one); // Экземпляр тега Riot
    console.log(this.refs.two); // HTML-елемент DOM
  });
<span class="nt">&lt;/my-tag&gt;</span>

</code></pre></div></div>

<p>В тех случаях, когда для нескольких элементов используется одно и то же значение <code class="highlighter-rouge">ref</code>, свойство <code class="highlighter-rouge">this.refs</code> возвращает массив соответствующих элементов/тегов. Например:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;my-tag&gt;</span>
  <span class="nt">&lt;div</span> <span class="na">data-ref=</span><span class="s">"items"</span> <span class="na">id=</span><span class="s">"alpha"</span><span class="nt">&gt;&lt;/div&gt;</span>
  <span class="nt">&lt;div</span> <span class="na">data-ref=</span><span class="s">"items"</span> <span class="na">id=</span><span class="s">"beta"</span><span class="nt">&gt;&lt;/div&gt;</span>

  this.on('mount', function() {
    console.log(this.refs.items); // [div#alpha, div#beta]
  });
<span class="nt">&lt;/my-tag&gt;</span>

</code></pre></div></div>

<h2 id="event-handlers">Обработчики DOM-событий</h2>

<p>Обработчики DOM-событий определяются следующим образом:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;login&gt;</span>
  <span class="nt">&lt;form</span> <span class="na">onsubmit=</span><span class="s">{</span> <span class="na">submit</span> <span class="err">}</span><span class="nt">&gt;</span>

  <span class="nt">&lt;/form&gt;</span>

  // Этот метод вызывается перед отправкой вышеописанной формы
  submit(e) {

  }
<span class="nt">&lt;/login&gt;</span>
</code></pre></div></div>

<p>Атрибуты, которые начинаются с “on”  (<code class="highlighter-rouge">onclick</code>, <code class="highlighter-rouge">onsubmit</code>, <code class="highlighter-rouge">oninput</code> и т.д.) принимают в качестве параметра функцию, которая будет обрабатывать действия. Этот параметр может быть так же определён динамически, в виде выражения:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;form</span> <span class="na">onsubmit=</span><span class="s">{</span> <span class="na">condition</span> <span class="err">?</span> <span class="na">method_a</span> <span class="na">:</span> <span class="na">method_b</span> <span class="err">}</span><span class="nt">&gt;</span>
</code></pre></div></div>

<p>Внутри этого обработчика, <code class="highlighter-rouge">this</code> относится к текущему экземпляру тега. После вызова обработчика, автоматически вызывается <code class="highlighter-rouge">this.update()</code>, отражая все возможные изменения в пользовательском интерфейсе (если только вы не установили <code class="highlighter-rouge">event.preventUpdate</code> в обработчике).</p>

<h3 id="event-object">Объект события</h3>

<p>Обработчик DOM-события принимает в качестве первого аргумента стандартный объект события. Ниже приведён список его свойств, которые работают во всех браузерах:</p>

<ul>
  <li><code class="highlighter-rouge">e.currentTarget</code> идентифицирует текущий DOM-элемент, в котором зарегистрирован работающий в данный момент обработчик события (на этапе всплытия события).</li>
  <li><code class="highlighter-rouge">e.target</code> идентифицирует элемент - инициатор события (т.е. узел, в котором произошло событие и с которого началась фаза всплывания). Он может не совпадать с <code class="highlighter-rouge">currentTarget</code>.</li>
  <li><code class="highlighter-rouge">e.which</code> код нажатой клавиши, если событие было вызвано нажатием клавиши (<code class="highlighter-rouge">keypress</code>, <code class="highlighter-rouge">keyup</code>, и т.д.).</li>
  <li><code class="highlighter-rouge">e.item</code> текущий элемент в цикле. Смотри подробности в разделе <a href="#loops">циклы</a>.</li>
</ul>

<h2 id="conditionals">Условия</h2>

<p>Условия помогают вам показывать/скрывать элементы в зависимости от ситуации:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;div</span> <span class="na">if=</span><span class="s">{</span> <span class="na">is_premium</span> <span class="err">}</span><span class="nt">&gt;</span>
  <span class="nt">&lt;p&gt;</span>This is for premium users only<span class="nt">&lt;/p&gt;</span>
<span class="nt">&lt;/div&gt;</span>
</code></pre></div></div>

<p>Ещё раз, выражения могут быть обычным свойством или полноценным JavaScript выражением. Вот список доступных условных атрибутов:</p>

<ul>
  <li><code class="highlighter-rouge">show</code> – показывает элемент, используя <code class="highlighter-rouge">style="display: ''"</code> если значение равно true</li>
  <li><code class="highlighter-rouge">hide</code> – скрывает элемент, используя <code class="highlighter-rouge">style="display: none"</code> если значение равно true</li>
  <li><code class="highlighter-rouge">if</code> – добавляет (при true) или удаляет (при false) элемент из документа</li>
</ul>

<p>Используется оператор равно <code class="highlighter-rouge">==</code>, а не строго равно <code class="highlighter-rouge">===</code>. То есть : <code class="highlighter-rouge">'a string' == true</code>.</p>

<h2 id="loops">Циклы</h2>

<p>Циклы реализованы благодаря атрибуту <code class="highlighter-rouge">each</code>:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;todo&gt;</span>
  <span class="nt">&lt;ul&gt;</span>
    <span class="nt">&lt;li</span> <span class="na">each=</span><span class="s">{</span> <span class="na">items</span> <span class="err">}</span> <span class="na">class=</span><span class="s">{</span> <span class="na">completed:</span> <span class="na">done</span> <span class="err">}</span><span class="nt">&gt;</span>
      <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">"checkbox"</span> <span class="na">checked=</span><span class="s">{</span> <span class="na">done</span> <span class="err">}</span><span class="nt">&gt;</span> { title }
    <span class="nt">&lt;/li&gt;</span>
  <span class="nt">&lt;/ul&gt;</span>

  this.items = [
    { title: 'First item', done: true },
    { title: 'Second item' },
    { title: 'Third item' }
  ]
<span class="nt">&lt;/todo&gt;</span>
</code></pre></div></div>

<p>Элемент с атрибутом <code class="highlighter-rouge">each</code> будет повторён для всех значений массива. Новый элемент будет автоматически добавлен/создан, если в массив добавится новое значение через такие методы, как <code class="highlighter-rouge">push()</code>, <code class="highlighter-rouge">slice()</code> или <code class="highlighter-rouge">splice()</code>.</p>

<h3 id="context">Контекст</h3>

<p>Новый контекст создаётся для каждого элемента массива. <code class="highlighter-rouge">this</code> всегда ссылается на <a href="api#tag-instance">экземпляр тега</a>. Если в цикле используется пользовательские теги, то все дочерние теги в цикле наследуют все родительские свойства и методы, которые не определены в самом дочернем элементе. Таким образом, Riot предотвращает нежелательное переопределение от родительского тега.</p>

<p>Родитель доступен через переменную <code class="highlighter-rouge">parent</code>. Например:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;todo&gt;</span>
  <span class="nt">&lt;div</span> <span class="na">each=</span><span class="s">{</span> <span class="na">items</span> <span class="err">}</span><span class="nt">&gt;</span>
    <span class="nt">&lt;h3&gt;</span>{ title }<span class="nt">&lt;/h3&gt;</span>
    <span class="nt">&lt;a</span> <span class="na">onclick=</span><span class="s">{</span> <span class="na">parent</span><span class="err">.</span><span class="na">remove</span> <span class="err">}</span><span class="nt">&gt;</span>Remove<span class="nt">&lt;/a&gt;</span>
  <span class="nt">&lt;/div&gt;</span>

  this.items = [ { title: 'First' }, { title: 'Second' } ]

  remove(event) {

  }
<span class="nt">&lt;/todo&gt;</span>
</code></pre></div></div>

<p>Всё, что находится внутри элемента с атрибутом <code class="highlighter-rouge">each</code>, принадлежит дочернему контексту. То есть, к <code class="highlighter-rouge">title</code> можно обращаться напрямую, но <code class="highlighter-rouge">remove</code> должен вызываться с префиксом <code class="highlighter-rouge">parent.</code> поскольку метод не является атрибутом элемента в цикле.</p>

<p>Перебираемые элементы являются экземплярами <a href="api#tag-instance">пользовательских тегов</a>. Riot не изменяет исходные элементы массива, поэтому новые свойства к ним не добавляются.</p>

<h3 id="event-handlers-with-looped-items">Обработчики DOM-событий в циклах</h3>

<p>Обработчики DOM-событий имеют доступ к элементу массива вызвавшему событие, через <code class="highlighter-rouge">event.item</code>. Вот пример функции <code class="highlighter-rouge">remove</code>:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;todo&gt;</span>
  <span class="nt">&lt;div</span> <span class="na">each=</span><span class="s">{</span> <span class="na">items</span> <span class="err">}</span><span class="nt">&gt;</span>
    <span class="nt">&lt;h3&gt;</span>{ title }<span class="nt">&lt;/h3&gt;</span>
    <span class="nt">&lt;a</span> <span class="na">onclick=</span><span class="s">{</span> <span class="na">parent</span><span class="err">.</span><span class="na">remove</span> <span class="err">}</span><span class="nt">&gt;</span>Remove<span class="nt">&lt;/a&gt;</span>
  <span class="nt">&lt;/div&gt;</span>

  this.items = [ { title: 'First' }, { title: 'Second' } ]

  remove(event) {

    // получить элемент
    var item = event.item

    // индекс элемента в массиве
    var index = this.items.indexOf(item)

    // удалить элемент из массива
    this.items.splice(index, 1)
  }
<span class="nt">&lt;/todo&gt;</span>
</code></pre></div></div>

<p>После того, как обработчик DOM-события выполнится, текущий экземпляр пользовательского тега обновится, используя <code class="highlighter-rouge">this.update()</code> (если только в обработчике не указано e.preventUpdate = true). Родитель следит за состоянием первоначального массива. Если какой-либо элемент был удалён из массива, родитель удаляет его из DOM.</p>

<h3 id="looping-custom-tags">Перебор пользовательских тегов</h3>

<p>Пользовательские теги так же могут быть использованы в циклах:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;todo-item</span> <span class="na">each=</span><span class="s">"{ items }"</span> <span class="na">data=</span><span class="s">"{ this }"</span><span class="nt">&gt;&lt;/todo-item&gt;</span>
</code></pre></div></div>

<p>Текущий элемент в цикле доступен через переменную <code class="highlighter-rouge">this</code>, которую вы можете использовать для передачи пользовательскому тегу параметров.</p>

<h3 id="non-object-arrays">Необъектные массивы</h3>

<p>Элементы массива не обязательно должны быть объектами. Они так же могут быть строками или числами. В этом случае, вы должны использовать конструкцию <code class="highlighter-rouge">{ value, key in items }</code>, как показано ниже:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;my-tag&gt;</span>
  <span class="nt">&lt;p</span> <span class="na">each=</span><span class="s">"{ value, key in arr }"</span><span class="nt">&gt;</span>{ key }: { value }<span class="nt">&lt;/p&gt;</span>

  this.arr = [true, 110, Math.random(), 'fourth']
<span class="nt">&lt;/my-tag&gt;</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">value</code> - это значение элемента, а <code class="highlighter-rouge">key</code> - его индекс. Оба этих имени вы можете выбрать на своё усмотрение, в зависимости от ситуации.</p>

<h3 id="object-loops">Перебор объектов</h3>

<p>Одноуровневые объекты так же могут быть использованы для циклов:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;my-tag&gt;</span>
  <span class="nt">&lt;p</span> <span class="na">each=</span><span class="s">"{ value, key in obj }"</span><span class="nt">&gt;</span>{ key } = { value }<span class="nt">&lt;/p&gt;</span>

  this.obj = {
    key1: 'value1',
    key2: 1110.8900,
    key3: Math.random()
  }
<span class="nt">&lt;/my-tag&gt;</span>
</code></pre></div></div>

<p>Не рекомендуется использовать циклы по объектам, так как Riot определяет, изменился ли объект с помощью <code class="highlighter-rouge">JSON.stringify</code>. Изучается <em>весь</em> объект целиком, и если в нём что-то меняется, то весь цикл рендерится заново. Обычные массивы гораздо быстрее и изменения отдельного элемента затрагивают конкретный элемент на странице.</p>

<h3 id="loops-advanced-tips">Полезные советы о циклах</h3>

<h4 id="performances">Производительность</h4>

<p>Алгоритм <code class="highlighter-rouge">each</code> по умолчанию будет синхронизировать положение узлов DOM в цикле с элементами в вашей коллекции, посредством поиска с помощью <code class="highlighter-rouge">indexOf</code>. Эта стратегия может быть неэффективной, если вы имеете дело с большими коллекциями данных. В этом случае, если ваши теги в цикле не нужно переупорядочивать, а достаточно обновить их шаблоны, то вы можете добавить к ним атрибут <code class="highlighter-rouge">no-reorder</code>.</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;loop&gt;</span>
  <span class="c">&lt;!-- `items` здесь может быть огромная коллекция данных... --&gt;</span>
  <span class="nt">&lt;table&gt;</span>
    <span class="nt">&lt;tr</span> <span class="na">each=</span><span class="s">"{ item in items }"</span> <span class="na">no-reorder</span><span class="nt">&gt;</span>
      <span class="nt">&lt;td&gt;</span>
        { item.name }
      <span class="nt">&lt;/td&gt;</span>
      <span class="nt">&lt;td&gt;</span>
        { item.surname }
      <span class="nt">&lt;/td&gt;</span>
    <span class="nt">&lt;/tr&gt;</span>
  <span class="nt">&lt;/table&gt;</span>
<span class="nt">&lt;/loop&gt;</span>
</code></pre></div></div>

<p>Строки таблицы в приведенном выше примере будут добавлены/удалены/обновлены без изменения порядковой позиции, изначально привязанной к ним.</p>

<h4 id="key">Ключ</h4>

<p><span class="tag red">&gt;= v3.7</span></p>

<p>Добавив <code class="highlighter-rouge">key</code> атрибут к тегам в цикле, вы обеспечите более точную стратегию для отслеживания позиции ваших элементов. Это значительно повысит производительность цикла, если ваши коллекции неизменны.</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;loop&gt;</span>
  <span class="nt">&lt;ul&gt;</span>
    <span class="nt">&lt;li</span> <span class="na">each=</span><span class="s">{</span> <span class="na">user</span> <span class="na">in</span> <span class="na">users</span> <span class="err">}</span> <span class="na">key=</span><span class="s">"id"</span><span class="nt">&gt;</span>{ user.name }<span class="nt">&lt;/li&gt;</span>
  <span class="nt">&lt;/ul&gt;</span>
  <span class="nt">&lt;script&gt;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">users</span> <span class="o">=</span> <span class="p">[</span>
      <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="s1">'Gian'</span><span class="p">,</span> <span class="na">id</span><span class="p">:</span> <span class="mi">0</span> <span class="p">},</span>
      <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="s1">'Dan'</span><span class="p">,</span> <span class="na">id</span><span class="p">:</span> <span class="mi">1</span> <span class="p">},</span>
      <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="s1">'Teo'</span><span class="p">,</span> <span class="na">id</span><span class="p">:</span> <span class="mi">2</span> <span class="p">}</span>
    <span class="p">]</span>
  <span class="nt">&lt;/script&gt;</span>
<span class="nt">&lt;/loop&gt;</span>
</code></pre></div></div>

<p>Атрибут <code class="highlighter-rouge">key</code> может быть сгенерирован также с помощью выражений</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;loop&gt;</span>
  <span class="nt">&lt;ul&gt;</span>
    <span class="nt">&lt;li</span> <span class="na">each=</span><span class="s">{</span> <span class="na">user</span> <span class="na">in</span> <span class="na">users</span> <span class="err">}</span> <span class="na">key=</span><span class="s">{</span> <span class="na">user</span><span class="err">.</span><span class="na">id</span><span class="err">()</span> <span class="err">}</span><span class="nt">&gt;</span>{ user.name }<span class="nt">&lt;/li&gt;</span>
  <span class="nt">&lt;/ul&gt;</span>
  <span class="nt">&lt;script&gt;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">users</span> <span class="o">=</span> <span class="p">[</span>
      <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="s1">'Gian'</span><span class="p">,</span> <span class="nx">id</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span> <span class="p">}</span> <span class="p">},</span>
      <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="s1">'Dan'</span><span class="p">,</span> <span class="nx">id</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">1</span> <span class="p">}</span> <span class="p">},</span>
      <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="s1">'Teo'</span><span class="p">,</span> <span class="nx">id</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">2</span> <span class="p">}</span> <span class="p">}</span>
    <span class="p">]</span>
  <span class="nt">&lt;/script&gt;</span>
<span class="nt">&lt;/loop&gt;</span>
</code></pre></div></div>

<h4 id="the-virtual-tag">Тег <code class="highlighter-rouge">virtual</code></h4>

<p>В некоторых случаях, вам может потребоваться перебирать теги без родительского тега-обёртки. В этом случае, вы можете использовать тег <code class="highlighter-rouge">&lt;virtual&gt;</code>, который удаляется, будто html-теги ни во что не обёртывались. Например:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;dl&gt;</span>
  <span class="nt">&lt;virtual</span> <span class="na">each=</span><span class="s">{item</span> <span class="na">in</span> <span class="na">items</span><span class="err">}</span><span class="nt">&gt;</span>
    <span class="nt">&lt;dt&gt;</span>{item.key}<span class="nt">&lt;/dt&gt;</span>
    <span class="nt">&lt;dd&gt;</span>{item.value}<span class="nt">&lt;/dd&gt;</span>
  <span class="nt">&lt;/virtual&gt;</span>
<span class="nt">&lt;/dl&gt;</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">virtual</code>  однако, не используется исключительно для циклов и может применяться в сочетании с <code class="highlighter-rouge">if</code> для любого тега</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;virtual</span> <span class="na">if=</span><span class="s">{condition}</span><span class="nt">&gt;</span>
  <span class="nt">&lt;p&gt;</span>Show me with no wrapper on condition<span class="nt">&lt;/p&gt;</span>
<span class="nt">&lt;/virtual&gt;</span>
</code></pre></div></div>

<h2 id="html-elements-as-tags">HTML-элементы как теги</h2>

<p>Стандартные HTML-элементы могут быть использованы как пользовательские теги, путём добавления атрибута <code class="highlighter-rouge">data-is</code>.</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;ul</span> <span class="na">data-is=</span><span class="s">"my-list"</span><span class="nt">&gt;&lt;/ul&gt;</span>
</code></pre></div></div>

<p>Это предоставляет пользователям альтернативу, которая может обеспечить большую совместимость с платформами CSS. Такой тег рассматривается, как любой другой пользовательский тег.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">riot</span><span class="p">.</span><span class="nx">mount</span><span class="p">(</span><span class="s1">'my-list'</span><span class="p">)</span>
</code></pre></div></div>

<p>будет монтировать элемент <code class="highlighter-rouge">ul</code> показанный выше, как если бы это был <code class="highlighter-rouge">&lt;my-list&gt;&lt;/my-list&gt;</code></p>

<p>Обратите внимание, что вы также можете использовать выражение в атрибуте <code class="highlighter-rouge">data-is</code> и Riot сможет динамически отображать также разные теги на одном и том же узле DOM</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;my-tag&gt;</span>
  <span class="c">&lt;!-- динамический компонент --&gt;</span>
  <span class="nt">&lt;div</span> <span class="na">data-is=</span><span class="s">{</span> <span class="na">component</span> <span class="err">}</span><span class="nt">&gt;&lt;/div&gt;</span>
  <span class="nt">&lt;button</span> <span class="na">onclick=</span><span class="s">{</span> <span class="na">switchComponent</span> <span class="err">}</span><span class="nt">&gt;</span>
    Switch
  <span class="nt">&lt;/button&gt;</span>

  <span class="nt">&lt;script&gt;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">component</span> <span class="o">=</span> <span class="s1">'foo'</span>

    <span class="nx">switchComponent</span><span class="p">()</span> <span class="p">{</span>
      <span class="c1">// riot отрендерит компонент </span><span class="o">&lt;</span><span class="nx">bar</span><span class="o">&gt;</span>
      <span class="c1">// заменив </span><span class="o">&lt;</span><span class="nx">foo</span><span class="o">&gt;</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">component</span> <span class="o">=</span> <span class="s1">'bar'</span>
    <span class="p">}</span>
  <span class="nt">&lt;/script&gt;</span>
<span class="nt">&lt;/my-tag&gt;</span>
</code></pre></div></div>

<p>Обратите внимание, что при использовании атрибута <code class="highlighter-rouge">data-is</code>, имя тега должно набираться строчными буквами, независимо от того, как оно определено.</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nt">&lt;MyTag&gt;&lt;/MyTag&gt;</span> <span class="c">&lt;!-- Правильно --&gt;</span>
  <span class="nt">&lt;div</span> <span class="na">data-is=</span><span class="s">"mytag"</span><span class="nt">&gt;&lt;/div&gt;</span> <span class="c">&lt;!-- Тоже Правильно --&gt;</span>
  <span class="nt">&lt;div</span> <span class="na">data-is=</span><span class="s">"MyTag"</span><span class="nt">&gt;&lt;/div&gt;</span> <span class="c">&lt;!-- Ошибка --&gt;</span>
  <span class="nt">&lt;script </span><span class="na">type=</span><span class="s">"text/javascript"</span><span class="nt">&gt;</span>
    <span class="nx">riot</span><span class="p">.</span><span class="nx">mount</span><span class="p">(</span><span class="s1">'MyTag'</span><span class="p">);</span>
  <span class="nt">&lt;/script&gt;</span>
</code></pre></div></div>

<h2 id="server-side-rendering">Рендеринг на стороне сервера</h2>

<p>Riot поддерживает рендеринг на стороне сервера с помощью Node/io.js. Вы можете использовать <code class="highlighter-rouge">require</code> и рендерить теги:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">riot</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'riot'</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">timer</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'timer.tag'</span><span class="p">)</span>

<span class="kd">var</span> <span class="nx">html</span> <span class="o">=</span> <span class="nx">riot</span><span class="p">.</span><span class="nx">render</span><span class="p">(</span><span class="nx">timer</span><span class="p">,</span> <span class="p">{</span> <span class="na">start</span><span class="p">:</span> <span class="mi">42</span> <span class="p">})</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">html</span><span class="p">)</span> <span class="c1">// &lt;timer&gt;&lt;p&gt;Seconds Elapsed: 42&lt;/p&gt;&lt;/timer&gt;</span>
</code></pre></div></div>

<h2 id="riot-dom-caveats">Riot DOM Предостережения</h2>

<p>Riot-теги полагаются на визуализацию браузерами, поэтому вы должны знать о некоторых ситуациях, когда ваши компоненты могут некорректно отображать свой шаблон.</p>

<p>Рассмотрим следующий тег:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
  <span class="nt">&lt;my-fancy-options&gt;</span>
    <span class="nt">&lt;option&gt;</span>foo<span class="nt">&lt;/option&gt;</span>
    <span class="nt">&lt;option&gt;</span>bar<span class="nt">&lt;/option&gt;</span>
  <span class="nt">&lt;/my-fancy-options&gt;</span>
  </code></pre></div></div>

<p>Эта разметка недействительна, если не введена в тег <code class="highlighter-rouge">&lt;select&gt;</code>:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
  <span class="c">&lt;!-- недопустимо, тег select разрешает только &lt;option&gt; в качестве дочерних элементов --&gt;</span>
  <span class="nt">&lt;select&gt;</span>
    <span class="nt">&lt;my-fancy-options</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;/select&gt;</span>
  
  <span class="c">&lt;!-- допустимо, мы будем отображать теги &lt;option&gt; используя &lt;select&gt; в качестве родителя --&gt;</span>
  <span class="nt">&lt;select</span> <span class="na">data-is=</span><span class="s">'my-fancy-options'</span><span class="nt">&gt;&lt;/select&gt;</span>
  
  </code></pre></div></div>

<p>Теги наподобие <code class="highlighter-rouge">table, select, svg...</code> не разрешают использовать пользовательские теги riot (включая <code class="highlighter-rouge">&lt;virtual&gt;</code>) в качестве дочерних.  Используйте <code class="highlighter-rouge">data-is</code>, как показано выше. <a href="https://github.com/riot/riot/issues/2206">больше информации</a></p>